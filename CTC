Option Explicit
Option Compare Database



#If VBA7 Then
    Private Declare PtrSafe Function OpenProcess Lib "kernel32" _
                                 (ByVal dwDesiredAccess As Long, _
                                  ByVal bInheritHandle As Long, _
                                  ByVal dwProcessId As Long) As Long
    
    
    Private Declare PtrSafe Function GetExitCodeProcess Lib "kernel32" _
                                        (ByVal hProcess As Long, _
                                         lpExitCode As Long) As Long
    
    
    Private Declare PtrSafe Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" _
                                        (ByVal lpBuffer As String, nSize As Long) As Long
#Else
    Private Declare Function OpenProcess Lib "kernel32" _
                                 (ByVal dwDesiredAccess As Long, _
                                  ByVal bInheritHandle As Long, _
                                  ByVal dwProcessId As Long) As Long


    Private Declare Function GetExitCodeProcess Lib "kernel32" _
                                        (ByVal hProcess As Long, _
                                         lpExitCode As Long) As Long


    Private Declare Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" _
                                        (ByVal lpBuffer As String, nSize As Long) As Long
#End If

Dim db As Connection
Dim fso As FileSystemObject
Dim strUserName As String
Dim lngFileID As Long
Dim crlf As String
Dim stab As String
Dim PathZipProgram As String
Dim ZipCompress As String
Dim ZipListFlag As String
Dim NoCTOutput As Boolean
Dim EditFail As Boolean
Dim TimeOffset As Integer
Dim Debug_Enabled As Boolean
Dim DebugOutput As String

Dim ClipBoard As DataObject 'CTC 091 Copy job number

'Configurable path variables
Dim DTPProcessingFolder As String
Dim RootJobFolder As String
Dim AutoLoadFolder As String
Dim ArchiveFolder As String
Dim InterimFolder As String
Dim ClientEmailFolder As String
Dim FileExistsTriggerFolder As String
Dim DataInCallTraceFolder As String
Dim PGPTemporaryFolder As String
Dim EmailLogFolder As String
Dim DTPFailedFolder As String
Dim InTouchFolder As String

Const SoftwareVersion = "1.82"
' CTC 101 Update Provider to avoid using TLS 1.0 from Provider=MSDASQL.1 to Provider=SQLNCLI11
' CTC 114 - Revised Connection String Update to MSOLEDBSQL
Const ConnectionTemplate = "Provider=MSOLEDBSQL;Persist Security Info=False;Extended Properties=""DSN=Main;Description=Main Database;APP=Visual Basic;Trusted_Connection=Yes"";server=<ACTIVE_SERVER>;database=DataBureauDataLoadAudit;driver={SQL Server}"

Dim ConnectionString As String
Dim PS_Script As String

Const PROCESS_QUERY_INFORMATION = &H400
Const STILL_ACTIVE = &H103


Public Function blnIsTeamLeader() As Boolean
    Dim strSQL As String
    Dim rst As Recordset
    
    Set rst = New Recordset
    
    strSQL = "select TeamLeader from dbo.CT_Users where username = '" & strUserName & "' and TeamLeader = 'Y'"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    If Not rst.EOF Then
        blnIsTeamLeader = True
    Else
        blnIsTeamLeader = False
    End If
    rst.Close
End Function

Public Function Debug_Log() As Boolean

    Dim DebugMode As Boolean
    Dim LogFile As String
    Dim fso As New FileSystemObject
       
    If Debug_Enabled = "True" Then
        If fso.FileExists(DebugOutput) Then
            Debug_Log = True
        Else
            Debug_Log = False
            MsgBox ("There is no present log output file")
        End If
    Else
        Debug_Log = False
    End If

End Function

Private Sub Write_DebugLog(strText As String)
    
    Dim fso As New FileSystemObject
    Dim ts As TextStream
    Dim LogFile As String
    Dim UserName As String
    
    UserName = Environ("username")
    
    If Debug_Log Then
        Set ts = fso.OpenTextFile(DebugOutput, ForAppending)
        ts.WriteLine Strings.Format(Now, "YYYY-MM-DD HH:nn:ss") & " " & UserName & " " & CStr(strText)
    Else
        Exit Sub
    End If

End Sub



' #CTC011
' amending the visibility of the form components on checkbox click and reverting to default values if the checkbox is checked off
Private Sub chkDefaultValues_Click()

If chkDefaultValues.Value = True Then
    txtbx3.Enabled = False
    txtbx4.Enabled = False
    txtbx5.Enabled = False
    txtbx6.Enabled = False
    txtbx7.Enabled = False
    cmb8.Enabled = False
    txtbx8.Enabled = False
    txtbx9.Enabled = False
    txtbx10.Enabled = False
    txtbx11.Enabled = False
    txtbx12.Enabled = False
    txtbx13.Enabled = False
    txtbx14.Enabled = False
    cmb15.Enabled = False
    txtbx15.Enabled = False
    txtbx16.Enabled = False
    txtbx17.Enabled = False
    txtbx18.Enabled = False
    txtbx3.Value = Replace(GetConfigValue("NewJobDefaultInBoundFolder"), "<JobNumber>", lblJobNumbValue.Caption)
    txtbx4.Value = Replace(GetConfigValue("NewJobDefaultOutBoundFolder"), "<JobNumber>", lblJobNumbValue.Caption)
    txtbx5.Value = "%"
    txtbx6.Value = ""
    txtbx7.Value = ""
    cmb8.Value = "csv"
    txtbx9.Value = ""
    txtbx10.Value = "0"
    txtbx11.Value = "1"
    txtbx12.Value = ""
    txtbx13.Value = ""
    txtbx14.Value = "Zipped"
    cmb15.Value = "pdf"
    txtbx16.Value = "4"
    txtbx17.Value = "1"
    txtbx18.Value = "0"
    cmdMoreOptions.Visible = True
    cmdLessOptions.Visible = False
    cmdMoreOptions.Enabled = False
    txtbx5.Visible = False
    txtbx6.Visible = False
    txtbx7.Visible = False
    txtbx9.Visible = False
    txtbx10.Visible = False
    txtbx11.Visible = False
    txtbx12.Visible = False
    txtbx13.Visible = False
    txtbx15.Visible = False
    cmb15.Visible = False
    txtbx16.Visible = False
    txtbx17.Visible = False
    txtbx18.Visible = False
Else
    cmdMoreOptions.Enabled = True
    txtbx3.Enabled = True
    txtbx4.Enabled = True
    txtbx5.Enabled = True
    txtbx6.Enabled = True
    txtbx7.Enabled = True
    cmb8.Enabled = True
    txtbx8.Enabled = True
    txtbx9.Enabled = True
    txtbx10.Enabled = True
    txtbx12.Enabled = True
    txtbx13.Enabled = True
    txtbx14.Enabled = True
    cmb15.Enabled = True
    txtbx15.Enabled = True
    txtbx16.Enabled = True
    txtbx17.Enabled = True
    txtbx18.Enabled = True
End If

End Sub

Private Sub chkLaunchJob_AfterUpdate()

If Me.chkLaunchJob.Value = True Then
    Me.cmdProcess.Caption = "Setup Job and Launch"
    Me.cmdProcess.FontSize = 10
Else
    Me.cmdProcess.Caption = "Setup Job"
    Me.cmdProcess.FontSize = 11
End If

End Sub

Private Sub chkLaunchJob_Click()

Dim strSQL As String
Dim rst As Recordset
Dim blnProceed As Boolean

Set rst = New Recordset

If chkLaunchJob.Value = True Then
    
    ' Check if Launch is Enabled or not
    strSQL = "select ConfigValue from dbo.CT_Config where ConfigItem = 'Launch Enabled'"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    If rst.EOF Then
        MsgBox ("Launch Currently Disabled")
        blnProceed = False
    Else
        If LCase(rst("ConfigValue")) = "true" Then
            blnProceed = True
        Else
            MsgBox ("Launch Currently Disabled")
            blnProceed = False
        End If
    End If
    rst.Close
    
    If blnProceed = False Then
    
        chkLaunchJob.Value = False
        MsgBox ("you can set up this job, however launching should be done separately from Job Details table when Launching is enabled")
        
    End If

End If

    
End Sub

' #CTC011
' preventing editing the combobox selected value
Private Sub cmb15_KeyPress(KeyAscii As Integer)
    KeyAscii = 0
End Sub

' #CTC011
' preventing editing the combobox selected value
Private Sub cmb8_KeyPress(KeyAscii As Integer)
    KeyAscii = 0
End Sub

' #CTC011
' selecting the job from the listed ones in combobox
Private Sub cmbJobs_Click()

Dim strSQLlbl As String
Dim strNameComNEP As String
Dim strJob As String
Dim rst As Recordset
Set rst = New Recordset
lblNeptuneClientNameValue.Visible = True
lblJobNumbValue.Visible = True
lblClientStatusValue.Visible = True
lblComparabilityValue.Visible = True
lblNeptuneClientName.ForeColor = vbBlack
lblJobNumb.ForeColor = vbBlack
lblClientStatus.ForeColor = vbBlack
lblComparability.ForeColor = vbBlack
cmdAddNewJob.Enabled = False
chkDefaultValues.Enabled = False
cmdCancelAddNewJob.Enabled = True
chkDefaultValues.Value = True
chkDefaultValues.Visible = False
lblDefVal.Visible = False
txtbx3.Visible = False
txtbx4.Visible = False
txtbx5.Visible = False
txtbx6.Visible = False
txtbx7.Visible = False
cmb8.Visible = False
txtbx8.Visible = False
txtbx9.Visible = False
txtbx10.Visible = False
txtbx11.Visible = False
txtbx12.Visible = False
txtbx13.Visible = False
txtbx14.Visible = False
cmb15.Visible = False
txtbx15.Visible = False
txtbx16.Visible = False
txtbx17.Visible = False
txtbx18.Visible = False
txtbx3.Enabled = False
txtbx4.Enabled = False
txtbx5.Enabled = False
txtbx6.Enabled = False
txtbx7.Enabled = False
cmb8.Enabled = False
txtbx8.Enabled = False
txtbx9.Enabled = False
txtbx10.Enabled = False
txtbx11.Enabled = False
txtbx12.Enabled = False
txtbx13.Enabled = False
txtbx14.Enabled = False
cmb15.Enabled = False
txtbx15.Enabled = False
txtbx16.Enabled = False
txtbx17.Enabled = False
txtbx18.Enabled = False

cmdMoreOptions.Visible = False
cmdMoreOptions.Enabled = False
cmdLessOptions.Visible = False

' looking up the Neptune client name
strJob = Trim(cmbJobs.Value)
strSQLlbl = "SELECT DISTINCT TOP 1 NC.CompanyName, NJ.JisID FROM Neptune.dbo.JIS NJ "
strSQLlbl = strSQLlbl & "INNER JOIN Neptune.dbo.Customer NC "
strSQLlbl = strSQLlbl & "ON NC.CustomerID = NJ.CustomerID "
strSQLlbl = strSQLlbl & "WHERE NJ.JobNo = '" & strJob & "' "
strSQLlbl = strSQLlbl & "ORDER BY NJ.JisID DESC "
rst.Open strSQLlbl, db, adOpenForwardOnly, adLockReadOnly
strNameComNEP = Replace(rst(Trim("CompanyName")), "'", "")
rst.Close
lblNeptuneClientNameValue.Caption = Replace(strNameComNEP, "&", "&&")
lblJobNumbValue.Caption = strJob

' the following section is the method to identify the situation of the currently selected job - how many times the client name is already stored in CT tables under the different clients
' and how many clients (under various names) share at least one historical job with the client from selected job number
Dim CT_Present_Count_Names As Integer
Dim CT_Present_Count_His_Jobs As Integer
Dim strSQL_CT_Names As String
Dim strSQL_CT_Jobs As String
Dim ProceedVar As String
Dim CT_His_Name As String
CT_Present_Count_Names = 0 ' how many times the client name is already stored in CT tables under the different clients
CT_Present_Count_His_Jobs = 0 ' how many clients (under various names) share at least one historical job with the client from selected job number

strSQL_CT_Names = "SELECT COUNT(DISTINCT CT_ClientID) AS QTY FROM DataBureauDataLoadAudit.dbo.CT_Clients WHERE ClientName = '" & strNameComNEP & "'"
rst.Open strSQL_CT_Names, db, adOpenForwardOnly, adLockReadOnly
CT_Present_Count_Names = CInt(rst("QTY"))
rst.Close

strSQL_CT_Jobs = "WITH CTE_TEMP AS "
strSQL_CT_Jobs = strSQL_CT_Jobs & "(SELECT DISTINCT TOP 1 NC.CompanyName, NJ.JisID FROM Neptune.dbo.JIS NJ "
strSQL_CT_Jobs = strSQL_CT_Jobs & "INNER JOIN Neptune.dbo.Customer NC "
strSQL_CT_Jobs = strSQL_CT_Jobs & "ON NC.CustomerID = NJ.CustomerID "
strSQL_CT_Jobs = strSQL_CT_Jobs & "WHERE NJ.JobNo = '" & lblJobNumbValue.Caption & "' "
strSQL_CT_Jobs = strSQL_CT_Jobs & "ORDER BY NJ.JisID DESC) "
strSQL_CT_Jobs = strSQL_CT_Jobs & "SELECT COUNT (DISTINCT CC.CT_ClientID) AS QTY FROM DataBureauDataLoadAudit.dbo.CT_Clients CC "
strSQL_CT_Jobs = strSQL_CT_Jobs & "INNER JOIN DataBureauDataLoadAudit.dbo.CT_Jobs CJ "
strSQL_CT_Jobs = strSQL_CT_Jobs & "ON CC.CT_ClientID = CJ.CT_ClientID "
strSQL_CT_Jobs = strSQL_CT_Jobs & "WHERE CJ.Job_Number IN "
strSQL_CT_Jobs = strSQL_CT_Jobs & "(SELECT DISTINCT JobNo FROM Neptune.dbo.JIS AS NJ "
strSQL_CT_Jobs = strSQL_CT_Jobs & "INNER JOIN Neptune.dbo.Customer NC "
strSQL_CT_Jobs = strSQL_CT_Jobs & "ON NJ.CustomerID = NC.CustomerID "
strSQL_CT_Jobs = strSQL_CT_Jobs & "WHERE NC.CompanyName = (SELECT CompanyName FROM CTE_TEMP)) "
rst.Open strSQL_CT_Jobs, db, adOpenForwardOnly, adLockReadOnly
CT_Present_Count_His_Jobs = CInt(rst("QTY"))
rst.Close

txtbx3.Value = Replace(GetConfigValue("NewJobDefaultInBoundFolder"), "<JobNumber>", lblJobNumbValue.Caption)
txtbx4.Value = Replace(GetConfigValue("NewJobDefaultOutBoundFolder"), "<JobNumber>", lblJobNumbValue.Caption)
txtbx5.Value = "%"
txtbx6.Value = ""
txtbx7.Value = ""
cmb8.Value = "csv"
txtbx9.Value = ""
txtbx10.Value = "0"
txtbx11.Value = "1"
txtbx12.Value = ""
txtbx13.Value = ""
txtbx14.Value = "Zipped"
cmb15.Value = "pdf"
txtbx16.Value = "4"
txtbx17.Value = "1"
txtbx18.Value = "0"
pgeManagement.SetFocus
cmdLessOptions.Visible = False
txtbx5.Visible = False
txtbx6.Visible = False
txtbx7.Visible = False
txtbx9.Visible = False
txtbx10.Visible = False
txtbx11.Visible = False
txtbx12.Visible = False
txtbx13.Visible = False
txtbx15.Visible = False
cmb15.Visible = False
txtbx16.Visible = False
txtbx17.Visible = False
txtbx18.Visible = False

' depending on the different scenarios it allows or the denies the ability to add the job - the only situations when the job is allowed to add is either it is a new client (both counts returning 0)
' or there is only one exact matching client (both counts returning 1);
' all other scenarios return error code which will be present in the troubleshooting documentation
Select Case CT_Present_Count_Names
   Case 0
      Select Case CT_Present_Count_His_Jobs
         Case 0
            ProceedVar = "N0J0"
            lblProceed.Caption = Trim(ProceedVar)
            lblClientStatusValue.Caption = "New"
            lblClientStatusValue.ForeColor = vbGreen
            cmdAddNewJob.Enabled = True
            chkDefaultValues.Enabled = True
            chkDefaultValues.Visible = True
            lblDefVal.Visible = True
            txtbx3.Visible = True
            txtbx4.Visible = True
            cmb8.Visible = True
            txtbx8.Visible = True
            txtbx14.Visible = True
            cmdMoreOptions.Visible = True
            lblComparabilityValue.Caption = "No issues. You can proceed adding the job."
            lblComparabilityValue.ForeColor = vbGreen
            
         Case 1
            ProceedVar = "N0J1"
            lblProceed.Caption = Trim(ProceedVar)
            lblClientStatusValue.Caption = "Unknown"
            lblClientStatusValue.ForeColor = vbRed
            cmdAddNewJob.Enabled = False
            chkDefaultValues.Enabled = False
            cmdMoreOptions.Visible = False
            cmdMoreOptions.Enabled = False
            lblComparabilityValue.Caption = "Error code: N0J1. Please raise the issue with the team leader."
            lblComparabilityValue.ForeColor = vbRed
         Case Else
            ProceedVar = "N0JN"
            lblProceed.Caption = Trim(ProceedVar)
            lblClientStatusValue.Caption = "Unknown"
            lblClientStatusValue.ForeColor = vbRed
            cmdAddNewJob.Enabled = False
            chkDefaultValues.Enabled = False
            cmdMoreOptions.Visible = False
            cmdMoreOptions.Enabled = False
            lblComparabilityValue.Caption = "Error code: N0JN. Please raise the issue with the team leader."
            lblComparabilityValue.ForeColor = vbRed
      End Select
   Case 1
      Select Case CT_Present_Count_His_Jobs
         Case 0
            ProceedVar = "N1J0"
            lblProceed.Caption = Trim(ProceedVar)
            lblClientStatusValue.Caption = "Unknown"
            lblClientStatusValue.ForeColor = vbRed
            cmdAddNewJob.Enabled = False
            chkDefaultValues.Enabled = False
            cmdMoreOptions.Visible = False
            cmdMoreOptions.Enabled = False
            lblComparabilityValue.Caption = "Error code: N1J0. Please raise the issue with the team leader."
            lblComparabilityValue.ForeColor = vbRed
         Case 1
            ProceedVar = "N1J1"
            lblProceed.Caption = Trim(ProceedVar)
            strSQL_CT_Jobs = "WITH CTE_TEMP AS "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "(SELECT DISTINCT TOP 1 NC.CompanyName, NJ.JisID FROM Neptune.dbo.JIS NJ "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "INNER JOIN Neptune.dbo.Customer NC "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "ON NC.CustomerID = NJ.CustomerID "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "WHERE NJ.JobNo = '" & strJob & "' "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "ORDER BY NJ.JisID DESC) "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "SELECT DISTINCT TOP 1 CC.ClientName, CC.CT_ClientID FROM DataBureauDataLoadAudit.dbo.CT_Clients CC "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "INNER JOIN DataBureauDataLoadAudit.dbo.CT_Jobs CJ "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "ON CC.CT_ClientID = CJ.CT_ClientID "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "WHERE CJ.Job_Number IN "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "(SELECT DISTINCT JobNo FROM Neptune.dbo.JIS AS NJ "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "INNER JOIN Neptune.dbo.Customer NC "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "ON NJ.CustomerID = NC.CustomerID "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "WHERE NC.CompanyName = (SELECT CompanyName FROM CTE_TEMP)) "
            strSQL_CT_Jobs = strSQL_CT_Jobs & "ORDER BY CC.CT_ClientID DESC "
            rst.Open strSQL_CT_Jobs, db, adOpenForwardOnly, adLockReadOnly
            CT_His_Name = Trim(rst("ClientName"))
            rst.Close
            ' in case of both counts returning 1, a check needs to be performed on whether these are for the same client
            If (Trim(Replace(CT_His_Name, "'", "")) = Trim(strNameComNEP)) Then
               lblClientStatusValue.Caption = "Existing"
               lblClientStatusValue.ForeColor = vbGreen
               cmdAddNewJob.Enabled = True
               chkDefaultValues.Enabled = True
               chkDefaultValues.Visible = True
               lblDefVal.Visible = True
               txtbx3.Visible = True
               txtbx4.Visible = True
               cmb8.Visible = True
               txtbx8.Visible = True
               txtbx14.Visible = True
               cmdMoreOptions.Visible = True
               lblComparabilityValue.Caption = "No issues. You can proceed adding the job."
               lblComparabilityValue.ForeColor = vbGreen
               
            Else
               ProceedVar = "N1J1X"
               lblProceed.Caption = Trim(ProceedVar)
               lblClientStatusValue.Caption = "Unknown"
               lblClientStatusValue.ForeColor = vbRed
               cmdAddNewJob.Enabled = False
               chkDefaultValues.Enabled = False
               cmdMoreOptions.Visible = False
               cmdMoreOptions.Enabled = False
               lblComparabilityValue.Caption = "Error code: N1J1X. Please raise the issue with the team leader."
               lblComparabilityValue.ForeColor = vbRed
            End If
         Case Else
            ProceedVar = "N1JN"
            lblProceed.Caption = Trim(ProceedVar)
            lblClientStatusValue.Caption = "Unknown"
            lblClientStatusValue.ForeColor = vbRed
            cmdAddNewJob.Enabled = False
            chkDefaultValues.Enabled = False
            cmdMoreOptions.Visible = False
            cmdMoreOptions.Enabled = False
            lblComparabilityValue.Caption = "Error code: N1JN. Please raise the issue with the team leader."
            lblComparabilityValue.ForeColor = vbRed
      End Select
   Case Else
      Select Case CT_Present_Count_His_Jobs
         Case 0
            ProceedVar = "NNJ0"
            lblProceed.Caption = Trim(ProceedVar)
            lblClientStatusValue.Caption = "Unknown"
            lblClientStatusValue.ForeColor = vbRed
            cmdAddNewJob.Enabled = False
            chkDefaultValues.Enabled = False
            cmdMoreOptions.Visible = False
            cmdMoreOptions.Enabled = False
            lblComparabilityValue.Caption = "Error code: NNJ0. Please raise the issue with the team leader."
            lblComparabilityValue.ForeColor = vbRed
         Case 1
            ProceedVar = "NNJ1"
            lblProceed.Caption = Trim(ProceedVar)
            lblClientStatusValue.Caption = "Unknown"
            lblClientStatusValue.ForeColor = vbRed
            cmdAddNewJob.Enabled = False
            chkDefaultValues.Enabled = False
            cmdMoreOptions.Visible = False
            cmdMoreOptions.Enabled = False
            lblComparabilityValue.Caption = "Error code: NNJ1. Please raise the issue with the team leader."
            lblComparabilityValue.ForeColor = vbRed
         Case Else
            ProceedVar = "NNJN"
            lblProceed.Caption = Trim(ProceedVar)
            lblClientStatusValue.Caption = "Unknown"
            lblClientStatusValue.ForeColor = vbRed
            cmdAddNewJob.Enabled = False
            chkDefaultValues.Enabled = False
            cmdMoreOptions.Visible = False
            cmdMoreOptions.Enabled = False
            lblComparabilityValue.Caption = "Error code: NNJN. Please raise the issue with the team leader."
            lblComparabilityValue.ForeColor = vbRed
      End Select
End Select

End Sub

' #CTC089
' Remove Email objects from Add new job process
'Sub PopulateDeliveryNotificationsPanel()
'End Sub

' #CTC011
' preventing editing the combobox selected value
Private Sub cmbJobs_KeyPress(KeyAscii As Integer)
    KeyAscii = 0
End Sub


Private Sub cmd_ED_Back_Click()

pgJobDetail.Enabled = True
pgJobDetail.SetFocus

pgCheckError.Visible = False
pgCheckError.Enabled = False

End Sub

Private Sub cmd_ED_Fix_Click()

Dim strSQL As String
Dim rst As Recordset
Dim blnCanFix As Boolean

Set rst = New Recordset

If InStr(lbl_ED_Resolution.Caption, "No TeleAppend Responses, Escalate to Team Leader") = 1 Then
    If MsgBox("Tele Response is Zero, are you sure you want to continue?", vbYesNo) = vbYes Then
        strSQL = "Exec sp_FixCallTraceReportError '" & Trim(lbl_ED_JisID.Caption) & "',1"
        blnCanFix = True
    Else
        blnCanFix = False
    End If
Else
    strSQL = "Exec sp_FixCallTraceReportError '" & Trim(lbl_ED_JisID.Caption) & "'"
    blnCanFix = True
End If

If blnCanFix Then
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

    While Not rst.EOF
        Select Case rst("Variable")
        Case "Final Error State"
            lbl_ED_ErrorState.Caption = Trim(rst("Result"))
        Case "Final Error Details"
            lbl_ED_ErrorDetails.Caption = Trim(rst("Result"))
        Case "Resolution"
            lbl_ED_Resolution.Caption = Trim(rst("Result"))
        Case Else
        End Select
        rst.MoveNext
    Wend
    rst.Close

    cmd_ED_Back.SetFocus
    cmd_ED_Fix.Enabled = False

End If

End Sub

Private Sub cmd_JD_CheckError_Click()

Dim strSQL As String
Dim rst As Recordset
Dim blnCanFix As Boolean

Set rst = New Recordset

' sort the pages out
pgCheckError.Visible = True
pgCheckError.Enabled = True

lbl_ED_JobNumber.Caption = ""
lbl_ED_RunNumber.Caption = ""
lbl_ED_TestJob.Caption = ""
lbl_ED_JisID.Caption = ""
lbl_ED_CallTraceVersion.Caption = ""
lbl_ED_ErrorState.Caption = ""
lbl_ED_ErrorDetails.Caption = ""
lbl_ED_TeleAppendFlag.Caption = ""
lbl_ED_AuditHeaderTable.Caption = ""
lbl_ED_AuditHeaderID.Caption = ""
lbl_ED_TeleAppendInputRecords.Caption = ""
lbl_ED_TeleAppendResponses.Caption = ""
lbl_ED_Resolution.Caption = ""
lbl_ED_ExecutionCode.Caption = ""

blnCanFix = False

pgCheckError.SetFocus
pgJobDetail.Enabled = False

' Execute the procedure to return the information
strSQL = "Exec dbo.sp_CheckCallTraceIssue '" & Trim(lblJDJobNo.Caption) & "'," & Trim(lblJDRunNo.Caption)
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

While Not rst.EOF
    Select Case rst("Variable")
    Case "Job Number"
        lbl_ED_JobNumber.Caption = Trim(rst("Result"))
    Case "Version"
        lbl_ED_RunNumber.Caption = Trim(rst("Result"))
    Case "Test Job"
        lbl_ED_TestJob.Caption = Trim(rst("Result"))
    Case "JisID"
        lbl_ED_JisID.Caption = Trim(rst("Result"))
    Case "CallTrace Version"
        lbl_ED_CallTraceVersion.Caption = Trim(rst("Result"))
    Case "Error State"
        lbl_ED_ErrorState.Caption = Trim(rst("Result"))
    Case "Error Details"
        lbl_ED_ErrorDetails.Caption = Trim(rst("Result"))
    Case "TeleAppend Flag"
        lbl_ED_TeleAppendFlag.Caption = Trim(rst("Result"))
    Case "Audit Header Table"
        lbl_ED_AuditHeaderTable.Caption = Trim(rst("Result"))
    Case "Audit HeaderID"
        lbl_ED_AuditHeaderID.Caption = Trim(rst("Result"))
    Case "TeleAppend Input Records"
        lbl_ED_TeleAppendInputRecords.Caption = Trim(rst("Result"))
    Case "TeleAppend Responses"
        lbl_ED_TeleAppendResponses.Caption = Trim(rst("Result"))
    Case "Resolution"
        lbl_ED_Resolution.Caption = Trim(rst("Result"))
    Case "Execution Code"
        lbl_ED_ExecutionCode.Caption = Trim(rst("Result"))
        blnCanFix = True
    Case Else
    End Select
    rst.MoveNext
    
Wend
rst.Close

' is this a .net error without telephone responses?
If InStr(lbl_ED_Resolution.Caption, "No TeleAppend Responses, Escalate to Team Leader") = 1 Then
    ' operator can't fix but team leader can
    
    ' is this user a Team Leader?
    strSQL = "select * from dbo.CT_Users where username = '" & strUserName & "' and TeamLeader = 'Y'"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    If Not rst.EOF Then
        blnCanFix = True
    End If
    rst.Close
End If

' if job is not in a failed state then can't fix
If lblJDRunStatus.Caption <> "Failed" Then
    blnCanFix = False
End If

If blnCanFix Then
    cmd_ED_Fix.Enabled = True
Else
    cmd_ED_Fix.Enabled = False
End If

End Sub

' #CTC023
' a button to refresh the Active Jobs tab for more visual feel for the refresh duration
Private Sub cmdActiveJobsRefresh_Click()

    cmdActiveJobsRefresh.Caption = "Refreshing..."
    cmdActiveJobsRefresh.Enabled = False
    Call CheckNeptuneStatus
    lstActiveJobs.Requery
    cmdActiveJobsRefresh.Caption = "Refresh"
    cmdActiveJobsRefresh.Enabled = True
    
End Sub




' #CTC011
' button for adding the job with all the listed / selected parameters in the form
Private Sub cmdAddNewJob_Click()

Dim lngGrey As Long
lngGrey = RGB(150, 150, 150)
lblNeptuneClientNameValue.Visible = False
lblJobNumbValue.Visible = False
lblClientStatusValue.Visible = False
lblComparabilityValue.Visible = False
lblNeptuneClientName.ForeColor = lngGrey
lblJobNumb.ForeColor = lngGrey
lblClientStatus.ForeColor = lngGrey
lblComparability.ForeColor = lngGrey
cmdAddNewJob.Enabled = False
cmdCancelAddNewJob.Enabled = False
chkDefaultValues.Visible = False
lblDefVal.Visible = False
txtbx3.Visible = False
txtbx4.Visible = False
txtbx5.Visible = False
txtbx6.Visible = False
txtbx7.Visible = False
cmb8.Visible = False
txtbx8.Visible = False
txtbx9.Visible = False
txtbx10.Visible = False
txtbx11.Visible = False
txtbx12.Visible = False
txtbx13.Visible = False
txtbx14.Visible = False
cmb15.Visible = False
txtbx15.Visible = False
txtbx16.Visible = False
txtbx17.Visible = False
txtbx18.Visible = False
chkDefaultValues.Enabled = False
txtbx3.Enabled = False
txtbx4.Enabled = False
txtbx5.Enabled = False
txtbx6.Enabled = False
txtbx7.Enabled = False
cmb8.Enabled = False
txtbx8.Enabled = False
txtbx9.Enabled = False
txtbx10.Enabled = False
txtbx11.Enabled = False
txtbx12.Enabled = False
txtbx13.Enabled = False
txtbx14.Enabled = False
cmb15.Enabled = False
txtbx15.Enabled = False
txtbx16.Enabled = False
txtbx17.Enabled = False
txtbx18.Enabled = False

Dim ProceedVar As String
ProceedVar = Trim(lblProceed.Caption)

Dim strSQL As String
Dim C_ID As Integer
Dim rst As Recordset
Set rst = New Recordset

' adding the job for a new client
If ProceedVar = "N0J0" Then
   strSQL = "INSERT INTO DataBureauDataLoadAudit.dbo.CT_Clients (ClientName, ClientNotes) "
   strSQL = strSQL & "VALUES ('" & Replace(Trim(lblNeptuneClientNameValue.Caption), "&&", "&") & "', '')"
   db.Execute (strSQL)
End If

' CTC 089 - Tidy up duplicated code
If ProceedVar = "N0J0" Or ProceedVar = "N1J1" Then
   
   strSQL = "SELECT CT_ClientID FROM DataBureauDataLoadAudit.dbo.CT_Clients "
   strSQL = strSQL & "WHERE ClientName = '" & Replace(Trim(lblNeptuneClientNameValue.Caption), "&&", "&") & "'"
   rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
   C_ID = rst("CT_ClientID")
   rst.Close
   
   strSQL = "INSERT INTO CT_Jobs (CT_ClientID, "
   strSQL = strSQL & "Job_Number, "
   strSQL = strSQL & "InboundFolder, "
   strSQL = strSQL & "OutboundFolder, "
   strSQL = strSQL & "InboundFileSpec, "
   strSQL = strSQL & "OutboundNamingConvention, "
   strSQL = strSQL & "ConnectDirectScript, "
   strSQL = strSQL & "OutputFileFormat, "
   strSQL = strSQL & "JobNotes, "
   strSQL = strSQL & "OutputToSFTP, "
   strSQL = strSQL & "JobActive, "
   strSQL = strSQL & "ReconNamingConvention, "
   strSQL = strSQL & "ZipFileNamingConvention, "
   strSQL = strSQL & "OutputType, "
   strSQL = strSQL & "ReportFormat, "
   strSQL = strSQL & "CTVersion, "
   strSQL = strSQL & "SLA_Days, "
   strSQL = strSQL & "PGP_Output, "
   strSQL = strSQL & "LaunchFolder) "
   strSQL = strSQL & "VALUES ('" & C_ID & "', "
   strSQL = strSQL & "'" & Trim(lblJobNumbValue.Caption) & "', "
   strSQL = strSQL & "'" & Trim(txtbx3.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx4.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx5.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx6.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx7.Value) & "', "
   strSQL = strSQL & "'" & Trim(cmb8.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx9.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx10.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx11.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx12.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx13.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx14.Value) & "', "
   strSQL = strSQL & "'" & Trim(cmb15.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx16.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx17.Value) & "', "
   strSQL = strSQL & "'" & Trim(txtbx18.Value) & "', "
   strSQL = strSQL & "0) "
   db.Execute (strSQL)
   
   MsgBox ("Job Created")
   
   ' CTC 089 - Add submitter email
   ' CTC 114 - After provider change procedure does not return data when successful insert has occurred
   strSQL = "exec up_CT_AddSubmitterEmail '" & Trim(lblJobNumbValue.Caption) & "' "
   rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
   
   If rst.Fields.Count = 0 Then
        ' Known problem returning data set from Stored Procedure, need to check the results separately
        strSQL = "exec [dbo].[up_CT_CheckSubmitterEmail] '" & Trim(lblJobNumbValue.Caption) & "'"
        rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    End If
    
    If rst("Success") = 1 Then
         MsgBox ("Submitter delivery email notification in place")
    Else
         MsgBox (rst("ErrorMessage"))
         MsgBox ("Unable to setup submitter to received delivery notification")
    End If
    rst.Close
  
End If

' refreshing the list of jobs in the combobox
Call listJobsInCmb

End Sub

' #CTC011
' cancelling the process of adding new job
Private Sub cmdCancelAddNewJob_Click()

Dim lngGrey As Long
lngGrey = RGB(150, 150, 150)
lblNeptuneClientNameValue.Visible = False
lblJobNumbValue.Visible = False
lblClientStatusValue.Visible = False
lblComparabilityValue.Visible = False
lblNeptuneClientName.ForeColor = lngGrey
lblJobNumb.ForeColor = lngGrey
lblClientStatus.ForeColor = lngGrey
lblComparability.ForeColor = lngGrey
cmdAddNewJob.Enabled = False
cmdCancelAddNewJob.Enabled = False
chkDefaultValues.Visible = False
lblDefVal.Visible = False
txtbx3.Visible = False
txtbx4.Visible = False
txtbx5.Visible = False
txtbx6.Visible = False
txtbx7.Visible = False
cmb8.Visible = False
txtbx8.Visible = False
txtbx9.Visible = False
txtbx10.Visible = False
txtbx11.Visible = False
txtbx12.Visible = False
txtbx13.Visible = False
txtbx14.Visible = False
cmb15.Visible = False
txtbx15.Visible = False
txtbx16.Visible = False
txtbx17.Visible = False
txtbx18.Visible = False
chkDefaultValues.Enabled = False
txtbx3.Enabled = False
txtbx4.Enabled = False
txtbx5.Enabled = False
txtbx6.Enabled = False
txtbx7.Enabled = False
cmb8.Enabled = False
txtbx8.Enabled = False
txtbx9.Enabled = False
txtbx10.Enabled = False
txtbx11.Enabled = False
txtbx12.Enabled = False
txtbx13.Enabled = False
txtbx14.Enabled = False
cmb15.Enabled = False
txtbx15.Enabled = False
txtbx16.Enabled = False
txtbx17.Enabled = False
txtbx18.Enabled = False
cmdMoreOptions.Visible = False
cmdMoreOptions.Enabled = False
cmdLessOptions.Visible = False

Call listJobsInCmb

End Sub

Private Sub cmdCancelJob_Click()

Dim JobNumber As String
Dim JobRun As String
Dim JobRunID As Long
Dim JobFolder As String
Dim AutomationFolder As String
Dim CancelledFolder As String
Dim TempTarget As String
Dim Suffix As Integer
Dim SQL As String
Dim rst As Recordset
Dim PreviousCancellations As Integer

Set rst = New Recordset

JobNumber = Trim(lblJDJobNo.Caption)
JobRun = Trim(lblJDRunNo.Caption)
JobRunID = CStr(lblJDRunID.Caption)
JobFolder = RootJobFolder & JobNumber & "_" & JobRun
CancelledFolder = RootJobFolder & JobNumber & "_" & JobRun & "_Cancelled"
AutomationFolder = AutoLoadFolder & JobNumber & "\" & JobNumber & "_" & JobRun

If MsgBox("Are you sure you wish to Cancel job - " & JobNumber & ", Run " & JobRun & "?", vbYesNo) = vbYes Then

    If Val(JobRun) = 0 Then
        MsgBox ("This is a new Job and so will not be marked as Complete Verified in Neptune" & crlf & "If you wish to cancel the job entirely use Neptune to Refer it")
    Else
        ' Complete Verify Neptune Job
        SQL = "exec DataBureauDataLoadAudit.dbo.up_CompleteVerifyNeptune '" & JobNumber & "', " & JobRun
        db.Execute (SQL)
    End If
    
    ' Delete the old folder before archiving
    Do While fso.FolderExists(JobFolder & "\Old")
        On Error Resume Next
        fso.DeleteFolder JobFolder & "\Old"
        If Err Then
            MsgBox ("Old folder could not be removed. Please manually remove the old folder and click OK to continue.")
        End If
        On Error GoTo 0
    Loop
    
    ' Copy results if any
    Call CopyFromAutoLoadFolder(JobNumber, JobRun)
        
    ' Renaming Folder to include _Cancelled - CTC 056 - this could possibly exist so if so use an incrementing number
    SQL = "select CancelCount from dbo.vw_CT_Run_Cancellations where Job_Number = '" & JobNumber & "' and RunNo = " & JobRun
    rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly
    If rst.EOF Then
        PreviousCancellations = 0
    Else
        PreviousCancellations = rst("CancelCount")
    End If
    rst.Close
    
    If PreviousCancellations > 0 Then
        CancelledFolder = CancelledFolder & "_" & Trim(str(PreviousCancellations + 1))
    End If
    
    If fso.FolderExists(JobFolder) Then
        fso.MoveFolder JobFolder, CancelledFolder
    End If
    
    If fso.FolderExists(CancelledFolder) Then
        ' Move to Archive
        fso.MoveFolder CancelledFolder, ArchiveFolder
    End If
                
    ' Delete Automation Folder
    If fso.FolderExists(AutomationFolder & "\Results") Then
        On Error Resume Next
        fso.DeleteFolder AutomationFolder & "\Results"
        If Err Then
            SQL = "insert into dbo.CT_FolderDeletions (Folder) values ('" & AutomationFolder & "\Results" & "')"
            db.Execute (SQL)
        End If
        On Error GoTo 0
    End If
                
    ' Delete Automation Folder
    If fso.FolderExists(AutomationFolder) Then
        On Error Resume Next
        fso.DeleteFolder AutomationFolder
        If Err Then
            SQL = "insert into dbo.CT_FolderDeletions (Folder) values ('" & AutomationFolder & "')"
            db.Execute (SQL)
        End If
        On Error GoTo 0
    End If
    
    ' Set Job Status to Cancelled
    Call UpdateRunStatus(CStr(JobRunID), "Cancelled", 0, "")
    Call SetActions("Cancelled")
    
End If

End Sub

Function SendFile(JobNumber As String, JobClient As String, RunNumber As String, SentFolder As String, DeliveryFolder As String, InternalDelivery As Boolean) As Boolean
' CTC 062 - Send delivery notifications to clients where required, also add a bit of control around the actual file copy process; deprecated
' CTC 076 - Use DTP process to deliver the job files as well as send the external client success notification
' TOT 217 - Split Process XML into Action XMLs, for faster processing of the DTP request
' CTC 093 - Added InternalDelivery parameter
On Local Error GoTo SendFile_Error

Dim SQL As String
Dim Email_To As String
Dim Email_CC As String
Dim Email_BCC As String
Dim rst As Recordset
Dim FileSent As Boolean
Dim NotificationEmail As Boolean
Dim FilePresent As String
Dim InterimSubFolder As String
Dim DTPProcessing As String
Dim PGP_Output As String
Dim EncryptionAdded As Boolean
Dim PGPTempFolder As String
Dim GUIDString As String
Dim nodeStep As Integer
Dim FileList As String
Dim FileListArray() As String
Dim FileName As Variant
Dim FileNamePGP As String

'Pending Folder Location for saving DTP action xmls
Dim SaveLocation As String
Dim DTPToLoad As String
Dim ActionListNames As String
Dim FirstActionPath As String

Set rst = New Recordset

'Generate GUID
GUIDString = GUID.CreateGuidString

'Join the path for interim location; Job and run number
InterimSubFolder = InterimFolder & JobNumber & "_" & RunNumber
'DTP Process step nodes start from 1
nodeStep = 1

FileSent = False
NotificationEmail = False
EncryptionAdded = False

' Is there something to send ?
FilePresent = Dir(SentFolder & "*.*")
If FilePresent = "" Then
    MsgBox ("No files found to send - Delivery Failed")
    SendFile = False
    Exit Function
End If

'CTC 076
'Get a list of files in the sent folder
FileList = ""
Do While FilePresent <> ""
    FileList = FileList & FilePresent
    FilePresent = Dir
    If FilePresent <> "" Then FileList = FileList & ";"
Loop
FileListArray = Split(FileList, ";")

' Is the target folder present
'CTC 079 We should only check for dynamically created delivery folders for individual jobs in Data Out
If InStr(LCase(DeliveryFolder), "\production\data out\calltrace") > 0 Then
    If Not fso.FolderExists(DeliveryFolder) Then
        MsgBox ("Target Location " & DeliveryFolder & " not found  - Delivery Failed")
        SendFile = False
        Exit Function
    End If
End If

' Is there an email notification required?
SQL = "select * from dbo.vw_CT_ClientDeliveryEmails where Job_Number = '" & JobNumber & "'"
rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly

If Not rst.EOF Then

    NotificationEmail = True

    While Not rst.EOF
        Select Case UCase(Trim(rst("EmailType")))
        Case "TO"
            Email_To = Email_To & Trim(rst("EmailAddress")) & ";"
        Case "CC"
            Email_CC = Email_CC & Trim(rst("EmailAddress")) & ";"
        Case "BCC"
            Email_BCC = Email_BCC & Trim(rst("EmailAddress")) & ";"
        End Select
        rst.MoveNext
    Wend
    ' always add DB for audit purposes
    Email_BCC = Email_BCC & "DataBureau@transunion.co.uk"
    
    ' must have something in TO otherwise email will fail
    If Len(Trim(Email_To)) = 0 Then
        MsgBox ("Client Notifications Emails are set for this job, but there is no primary 'Email To' recipient - Delivery Failed")
        SendFile = False
        Exit Function
    End If
End If
rst.Close

'CTC 076 Use DTP process to deliver files; Check for PGP
SQL = "select PGP_Output from ct_jobs where Job_Number = '" & Trim(JobNumber) & "'"
rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly
If Not rst.EOF Then
    If IsNull(rst("PGP_Output")) Then
        PGP_Output = "0"
    ElseIf rst("PGP_Output") = "False" Then
        PGP_Output = "0"
    ElseIf rst("PGP_Output") = "" Then
        PGP_Output = "0"
    ElseIf rst("PGP_Output") = "0" Then
        PGP_Output = "0"
    Else
        PGP_Output = rst("PGP_Output")
        EncryptionAdded = True
    End If
End If
rst.Close

'Get the location for saving the DTP XML files
SQL = "select ConfigValue from CT_Config where ConfigItem = 'DTPPendingFolder'"
rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly
SaveLocation = rst("ConfigValue")
rst.Close

'Get the location for moving the DTP XML action ToLoad folder
SQL = "select ConfigValue from CT_Config where ConfigItem = 'DTPToLoadFolder'"
rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly
DTPToLoad = rst("ConfigValue")
rst.Close

'CTC 076 Create subfolder in interim location, also if it already exists - overwrite it
If fso.FolderExists(InterimSubFolder) Then
    fso.DeleteFolder (InterimSubFolder)
End If
fso.CreateFolder (InterimSubFolder)

'Copy file to interim location here
fso.CopyFile SentFolder & "*.*", InterimSubFolder
FileSent = True

'Call DTP Add Copy Action
If EncryptionAdded Then

    'Set DTP temporary folder location for PGP
    PGPTempFolder = PGPTemporaryFolder & GUIDString

    'Get the one and only element from FileListArray; Append .pgp to filename that was encrypted
    FileName = FileListArray(0)
    FileNamePGP = CStr(FileName) & ".pgp"

    ' CTC 093 - internal target folders may not exist
    If InternalDelivery Then
        Call CreateNewFolderNode(GUIDString, ActionListNames, SaveLocation, nodeStep, DeliveryFolder, JobNumber, JobClient)
    End If
            
    Call CreateEncryptionNode(GUIDString, ActionListNames, SaveLocation, nodeStep, CStr(FileName), InterimSubFolder, PGPTempFolder, PGP_Output, JobNumber, JobClient)
    'If it's been encrypted, copy from PGP Temporary location to Delivery
    Call CreateCopyNode(GUIDString, ActionListNames, SaveLocation, nodeStep, PGPTempFolder, DeliveryFolder, FileNamePGP, JobNumber, JobClient)
    'After file has been delivered, DTP can delete the temporary location used for PGP encryption
    Call CreateDeletionNode(GUIDString, ActionListNames, SaveLocation, nodeStep, PGPTempFolder, JobNumber, JobClient)
    'After file has been delivered, DTP can delete the interim location subfolder
    Call CreateDeletionNode(GUIDString, ActionListNames, SaveLocation, nodeStep, InterimSubFolder, JobNumber, JobClient)
    
ElseIf Not EncryptionAdded Then

    ' CTC 093 - internal target folders may not exist
    If InternalDelivery Then
        Call CreateNewFolderNode(GUIDString, ActionListNames, SaveLocation, nodeStep, DeliveryFolder, JobNumber, JobClient)
    End If

    'If it's not been encrypted, copy all files from interim location to Delivery
    For Each FileName In FileListArray
        Call CreateCopyNode(GUIDString, ActionListNames, SaveLocation, nodeStep, InterimSubFolder, DeliveryFolder, FileName, JobNumber, JobClient)
    Next
    
    'After file has been delivered, DTP can delete the interim location subfolder
    Call CreateDeletionNode(GUIDString, ActionListNames, SaveLocation, nodeStep, InterimSubFolder, JobNumber, JobClient)

End If

' Send the email if required
If NotificationEmail Then
'Use .pgp to the end of the filename if it was encrypted
    If EncryptionAdded Then
        Call CreateEmailNode(GUIDString, ActionListNames, SaveLocation, nodeStep, FileNamePGP, DeliveryFolder, Email_To, Email_CC, Email_BCC, GUIDString, JobNumber, JobClient)
    ElseIf Not EncryptionAdded Then
        Call CreateEmailNode(GUIDString, ActionListNames, SaveLocation, nodeStep, FileListArray, DeliveryFolder, Email_To, Email_CC, Email_BCC, GUIDString, JobNumber, JobClient)
    End If
End If

'Move the first action into the ToLoad folder
FirstActionPath = Split(ActionListNames, ";")(0)
fso.MoveFile FirstActionPath, DTPToLoad

' return success
SendFile = True

Exit Function

SendFile_Error:
    If FileSent Then
        MsgBox ("The file has been copied to interim location, but there was an error creating DTP request - Escalate To Technical Team Member")
    Else
        MsgBox ("An error has occurred before the file could be sent - Escalate To Technical Team Member")
        SendFile = False
    End If
    

End Function

Public Sub ClearFileLock(FileID As String, FileSource As String)
' remove the lock on a file if it exists

Dim SQL As String

SQL = "execute [dbo].[up_CT_ClearFileLock] " & FileID & ", '" & FileSource & "'"
db.Execute (SQL)

End Sub
Private Sub cmdDeliverJob_Click()

' first off need to copy the output files to the Sent folder, rename if neccessary and zip up if neccessary
'CTC 062 There is no more manually encrypted PGP files, as EFT does it automatically now, therefore the commented out code is now deprecated

Dim strAuditLog As String
Dim strDeliveryFolder As String
Dim strAutomationFolder As String
Dim strSentFolder As String
Dim strNotSentFolder As String
Dim rst As Recordset
Dim SQL As String
Dim MoveOK As Boolean
Dim OutputLogText As String

pgJobDetail.Enabled = False

Set rst = New Recordset

strSentFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Sent\"
strNotSentFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\NotSent\"

If CreateSentData(strAuditLog) Then

    OutputLogText = CheckSentDetails

    If MsgBox(OutputLogText & crlf & crlf & "Press OK to Continue or Cancel", vbOKCancel) = vbOK Then
        
        ' CTC 093 - added parameter to set for Internal Deliveries
        Dim InternalDelivery As Boolean
        Call CreateDeliveryDocument(strSentFolder, strDeliveryFolder, InternalDelivery)

        ' CTC 093
        If strDeliveryFolder = "" Then
            MsgBox "Unable to Deliver Job"
            Exit Sub
        End If
        
        'Check if it's Data Out path - if it is then create a folder for invidivual job
        'CTC 079 CallTrace Delivery Bug
        If InStr(LCase(strDeliveryFolder), "\production\data out\calltrace") > 0 Then
            If Not fso.FolderExists(strDeliveryFolder) Then
                fso.CreateFolder strDeliveryFolder
            End If
        End If

        'CTC 062 Client Notification Emails
        'CTC 076 Use DTP for file delivery
        'Call SendFile(Trim(lblJDJobNo.Caption), strSentFolder, strDeliveryFolder)
        ' CTC 093 - Added INternalDelivery as a new parameter
        Call SendFile(Trim(lblJDJobNo.Caption), Trim(lblJDClient.Caption), Trim(lblJDRunNo.Caption), strSentFolder, strDeliveryFolder, InternalDelivery)
        
        Call SendFileInternal(Trim(lblJDJobNo.Caption), Trim(lblJDClient.Caption), Trim(lblJDRunNo.Caption), strSentFolder)
                

        ' delete the old folder before archiving
        Do While fso.FolderExists(RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Old")
            On Error Resume Next
            fso.DeleteFolder RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Old"
            If Err Then
                MsgBox ("Old folder could not be removed. Please manually remove the old folder and click OK to continue.")
            End If
            On Error GoTo 0
        Loop

        ' archive job by moving folder to Archive location
        'CTC 072 Do error trapping when moving file to archive
MoveFile:
        On Error GoTo MoveFailed
        fso.MoveFolder RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption), ArchiveFolder
        On Error GoTo 0

        ' remove automation folder
        strAutomationFolder = AutoLoadFolder & Trim(lblJDJobNo.Caption) & "\" & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption)
        Do While fso.FolderExists(strAutomationFolder)
            On Error Resume Next
            fso.DeleteFolder strAutomationFolder
            If Err Then
                MsgBox ("Automation folder could not be removed. Please manually remove the automation folder and click OK to continue.")
            End If
            On Error GoTo 0
        Loop

        pgJobDetail.Enabled = True

        Call UpdateRunStatus(lblJDRunID.Caption, "Complete", 0, "")
        Call SetActions("Complete")

        MsgBox ("Job Delivered and Folder Archived")

        If Trim(lblJDRunNo.Caption) = "0" Then
            ' First run so run code to complete verify it
            SQL = "exec DataBureauDataLoadAudit.dbo.up_CompleteVerifyNeptune '" & Trim(lblJDJobNo.Caption) & "', 0"
            db.Execute (SQL)
            MsgBox ("Job Verified in Neptune")
        End If

    Else
        pgJobDetail.Enabled = True
    End If
Else
    pgJobDetail.Enabled = True
End If

Exit Sub

MoveFailed:
    On Error GoTo 0
    If MsgBox("Moving to archive failed" & vbCrLf & "Please close any applications such as SSMS, Neptune or folders which might be associated with the job and click OK to try again.", vbOKOnly, "Failed to move to Archive") = vbOK Then
        Resume MoveFile
    End If

End Sub

Function SendFileInternal(JobNumber As String, JobClient As String, RunNumber As String, SentFolder As String)
'Private Function SendFileInternal(JobNumber As String)

'CTC 133 - additional transfer to an internal location
Dim rst As Recordset
Dim strSQL As String
Dim strDeliveryFolder As String
Dim InternalDelivery As Boolean

Set rst = New Recordset

'To create destiantion folder
InternalDelivery = True

strSQL = "select OutputToDOTO, OutputToDSA, OutputToSDQ from dbo.CT_Jobs where Job_Number = '" & JobNumber & "'"
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly


If Not rst.EOF Then
    If Not IsNull(rst!OutputToDOTO) And rst!OutputToDOTO Then
        strDeliveryFolder = GetConfigValue("OutboundDOTO")
        MsgBox strDeliveryFolder
        Call SendFile(JobNumber, JobClient, RunNumber, SentFolder, strDeliveryFolder, InternalDelivery)
    End If
    If Not IsNull(rst!OutputToDSA) And rst!OutputToDSA Then
        strDeliveryFolder = GetConfigValue("OutboundDSA")
        MsgBox strDeliveryFolder
        Call SendFile(JobNumber, JobClient, RunNumber, SentFolder, strDeliveryFolder, InternalDelivery)
    End If
    If Not IsNull(rst!OutputToSDQ) And rst!OutputToSDQ Then
        strDeliveryFolder = GetConfigValue("OutboundSDQ")
        MsgBox strDeliveryFolder
        Call SendFile(JobNumber, JobClient, RunNumber, SentFolder, strDeliveryFolder, InternalDelivery)
    End If
End If

rst.Close

End Function



Private Sub cmdEditDueBy_Click()

Dim strDueBy As String

strDueBy = InputBox("Please enter the required Due Date", "", lblEditRunDueBy.Caption)

If Len(Trim(strDueBy)) > 0 Then
    lblEditRunDueBy.Caption = strDueBy
End If

End Sub

Private Sub cmdEditFail_Click()
' if the operator has selected an error entry in the list then we will update it, otherwise ignore the button press

Dim blnEdit As Boolean
Dim LogID As Long
Dim strSQL As String
Dim intI As Integer
Dim rst As Recordset
Set rst = New Recordset


If IsNull(lstRunDetails.Value) Then
    blnEdit = False
Else
    LogID = lstRunDetails.Value
    
    strSQL = "select * from dbo.vw_JobRunDetails R inner join dbo.vw_CT_ErrorType E on r.errortype = e.errortype where LogID = " & Trim(str(LogID))
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    If rst.EOF Then
        blnEdit = False
        rst.Close
    ElseIf IsNull(rst("ErrorType")) Then
        blnEdit = False
        rst.Close
    Else
        blnEdit = True
    End If
End If
        
If blnEdit Then

    pgLogError.Visible = True
    pgLogError.Enabled = True
    lstErrorType.Visible = True
    pgLogError.SetFocus
    
    EditFail = True        ' indicates this is editting an existing error
    
    lblErrorHeader.Caption = "Select Error Type and add TTP Number for job " & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption)
    
    pgJobDetail.Enabled = False

    ' set the TTP number to previous
    txtTTP.SetFocus
    txtTTP.Text = Trim(rst("TTP"))
    lblLogID.Visible = True
    lblLogID.Caption = Trim(rst("LogID"))
    lblLogID.Visible = False
        
    ' highlight the relevant list entry
    For intI = 0 To lstErrorType.ListCount - 1
        If Val(lstErrorType.ItemData(intI)) = Val(rst("ct_ErrorID")) Then
            lstErrorType.Selected(intI) = True
            Exit For
        End If
    Next intI
    
        
    'Call clearttp

End If

End Sub

Private Sub cmdEditRun_Click()

Dim strSQL As String
Dim intRunID As Long
Dim intI As Integer

Dim rst As Recordset
Set rst = New Recordset

intRunID = lblJDRunID.Caption

strSQL = "select * from dbo.vw_CallTrace_JobDetail where runid = " & Trim(str(intRunID))
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

If rst.EOF Then
    MsgBox ("Can't retrieve job details")
Else
    pgRunEdit.Visible = True
    pgRunEdit.Enabled = True
    pgRunEdit.SetFocus
    pgJobDetail.Enabled = False
   
    lblEditRunID.Caption = rst("RunID")
    lblEditClient.Caption = rst("Client")
    lblEditJobNumber.Caption = rst("JobNo")
    lblEditRunRunNo.Caption = rst("RunNo")
    
    lblEditCreatedBy.Caption = rst("CreatedBy")
'    lblCreatedDate.Caption = rst("JobCreatedDate")
    lblEditRunDueBy.Caption = rst("DueDate")
    
    lblEditRunStatus.Caption = rst("Status")
    
    lstJobStatus.Value = rst("Status")
    
    cmdEditRunCancel.SetFocus
    lstJobStatus.Visible = False
    
End If
 
End Sub


Private Sub cmdEditRunCancel_Click()

pgJobDetail.Enabled = True
pgJobDetail.SetFocus
pgRunEdit.Enabled = False
pgRunEdit.Visible = False

End Sub

Private Sub cmdEditRunNo_Click()

Dim strRun As String

strRun = InputBox("Please enter the required Run Number", "", lblEditRunRunNo.Caption)

If Len(Trim(strRun)) > 0 Then
    lblEditRunRunNo.Caption = strRun
End If

End Sub

Private Sub cmdEditRunSave_Click()

Dim strSQL As String
Dim strLogSQL As String
Dim strJobRun As String
Dim strDueBy  As String
Dim strStatus As String
Dim intQueryLen As Integer


strSQL = "Update dbo.ct_JobRun set "
intQueryLen = Len(strSQL)
strLogSQL = ""

' check what has changed
If lblJDRunStatus.Caption <> lblEditRunStatus.Caption Then
    strSQL = strSQL & "RunStatus = '" & lblEditRunStatus.Caption & "' ,"
    
    ' if status changes need to add to audit log
    strLogSQL = "insert into dbo.CT_RunStatusLog (CT_RunID, CT_Status, UserName, UpdateDate) values ("
    strLogSQL = strLogSQL & lblJDRunID.Caption & ", '"
    strLogSQL = strLogSQL & lblEditRunStatus.Caption & "', '"
    strLogSQL = strLogSQL & strUserName & "', getdate()) "
   
End If

If lblJDRunNo.Caption <> lblEditRunRunNo.Caption Then
    strSQL = strSQL & "RunNo = " & lblEditRunRunNo.Caption & ","
End If

If lblJDRunDueDate.Caption <> lblEditRunDueBy.Caption Then
    strSQL = strSQL & "DueByDate = '" & lblEditRunDueBy.Caption & "'"
End If

' if we have changed something then update database
If Len(strSQL) > intQueryLen Then
    ' remove last comma
    If Right(strSQL, 1) = "," Then
        strSQL = Left(strSQL, Len(strSQL) - 1)
    End If

    strSQL = strSQL & " where ct_runid = " & lblJDRunID.Caption
    db.Execute (strSQL)
    
    If Len(strLogSQL) > 0 Then
        db.Execute (strLogSQL)
    End If
    
    lblJDRunStatus.Caption = lblEditRunStatus.Caption
    lblJDRunNo.Caption = lblEditRunRunNo.Caption
    lblJDRunDueDate.Caption = lblEditRunDueBy.Caption

    Call PopulateRunDetailList

End If




pgJobDetail.Enabled = True
pgJobDetail.SetFocus
pgRunEdit.Enabled = False
pgRunEdit.Visible = False

Exit Sub

cmdEditRunSave_Click:
    MsgBox ("Unable to save changes")
    pgJobDetail.Enabled = True
    pgJobDetail.SetFocus
    pgRunEdit.Enabled = False
    pgRunEdit.Visible = False
    
End Sub

Private Sub cmdEditRunStatus_Click()

lstJobStatus.Visible = True

End Sub



Private Sub cmdErrorCancel_Click()

pgJobDetail.Enabled = True
pgJobDetail.SetFocus
lblErrorHeader.Caption = ""
lstErrorType.Visible = False
pgLogError.Visible = False
pgLogError.Enabled = False

End Sub

Private Sub cmdErrorOK_Click()

Dim strSQL As String
Dim blnOK As Boolean
Dim strStatus As String
Dim strTTP As String
Dim strError As String

Dim rst As Recordset
Set rst = New Recordset

If IsNull(lstErrorType.Value) Then
    MsgBox ("Select a failure reason from the list")
    blnOK = False
ElseIf Len(Trim(lblTTP.Caption)) = 0 Then
    If MsgBox("Record Without TTP Reference?", vbYesNo) = vbYes Then
        blnOK = True
    Else
        blnOK = False
    End If
ElseIf Len(Trim(lblTTP.Caption)) > 10 Then
    MsgBox ("TTP Reference too Long - Max 10 characters?")
    blnOK = False
Else
    blnOK = True
End If
    
If blnOK Then
    
    txtTTP.SetFocus
    strTTP = Trim(txtTTP.Text)
    pgJobDetail.Enabled = True
    pgJobDetail.SetFocus
    lblErrorHeader.Caption = ""
    lstErrorType.Visible = False
    pgLogError.Visible = False
    pgLogError.Enabled = False
    
    ' set status
    If lstErrorType.Value = 5 Then
        strStatus = "Data Issue"
    Else
        strStatus = "Failed"
    End If
    
    If EditFail Then
        ' updating existing error
        ' get the error text
        strSQL = "select * from dbo.vw_CT_ErrorType where ct_errorID = " & lstErrorType.Value
        rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
        
        If rst.EOF Then
            strError = ""
        Else
            strError = Trim(rst("ErrorType"))
        End If
        rst.Close
        
        ' update the record
        strSQL = "Update dbo.CT_RunStatusLog set CT_Status = '" & strStatus & "',"
        strSQL = strSQL & "ErrorType = '" & strError & "',"
        strSQL = strSQL & " TTP = '" & strTTP & "' "
        strSQL = strSQL & "Where CT_RunStatusLogID = " & Trim(lblLogID.Caption)
        
        db.Execute (strSQL)
    Else
        ' creating new error
        Call UpdateRunStatus(lblJDRunID.Caption, strStatus, lstErrorType.Value, Trim(lblTTP.Caption))
        Call SetActions(strStatus)
    End If
        
    Call PopulateRunDetailList
    
End If

End Sub

Private Sub cmdFailJob_Click()

pgLogError.Visible = True
pgLogError.Enabled = True
lstErrorType.Visible = True
pgLogError.SetFocus

EditFail = False        ' indicates this is a new error to log

lblErrorHeader.Caption = "Select Error Type and add TTP Number for job " & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption)

pgJobDetail.Enabled = False

Call clearttp

End Sub

Private Sub cmdFindJob_Click()
' Find a job and open it in the File Details page

Dim JobNumber As String
Dim RunNumber As String
Dim RunID As Long
Dim SQL As String
Dim rst As Recordset

Set rst = New Recordset

' check how many jobs are actually currently running
txtFindJobNumber.SetFocus
JobNumber = Trim(txtFindJobNumber.Text)
txtFindRunNumber.SetFocus
RunNumber = Trim(txtFindRunNumber.Text)

If Len(JobNumber) > 0 And Len(RunNumber) > 0 And IsNumeric(RunNumber) Then

    SQL = "select CT_RunID from dbo.CT_Jobs J inner join dbo.CT_JobRun R on R.CT_JobID=J.CT_JobID "
    SQL = SQL & "where J.Job_Number = '" & JobNumber & "' "
    SQL = SQL & "and   R.RunNo = " & RunNumber

    rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly
    If rst.EOF Then
        MsgBox ("Job Not Found")
    Else
        RunID = rst("CT_RunID")
        If RunID > 0 Then
            cmdAddJob.Enabled = True
            pgJobList.SetFocus
            pgeManagement.Visible = False
            Call Progressjob(RunID)
        Else
            MsgBox ("Job Not Found")
        End If
    End If
    rst.Close
Else
    MsgBox ("Job Not Found")
End If


End Sub

Private Sub cmdJDBack_Click()

'CTC 114 - Save time by closing details page after successful launch - so needs to be in a public sub
Call Close_DetailsPage

End Sub

Public Sub Close_DetailsPage()

' update job to say it's in use
Dim strSQL As String
strSQL = "update dbo.ct_jobrun set currentuser = null where ct_runid = " & Trim(lblJDRunID.Caption)
db.Execute strSQL

pgJobList.Enabled = True
pgJobList.SetFocus
pgJobDetail.Enabled = False
pgJobDetail.Visible = False

' #CTC020
lstCTFeedback.Value = Null
While lstCTFeedback.ListCount > 0
    lstCTFeedback.RemoveItem (0)
Wend
lstCTFeedback.ColumnHeads = False

' #CTC023
pgFileList.Enabled = True
pgRejected.Enabled = True
pgReports.Enabled = True
pgeManagement.Enabled = True

lstActiveJobs.Requery

End Sub
Public Sub Close_DetailsPage_AutoLaunch(RunID As String)

' update job to say it's in use
Dim strSQL As String
strSQL = "update dbo.ct_jobrun set currentuser = null where ct_runid = " & CLng(RunID)
db.Execute strSQL

pgJobList.Enabled = True
pgJobDetail.Enabled = False
pgJobDetail.Visible = False

' #CTC020
lstCTFeedback.Value = Null
While lstCTFeedback.ListCount > 0
    lstCTFeedback.RemoveItem (0)
Wend
lstCTFeedback.ColumnHeads = False

' #CTC023
pgFileList.Enabled = True
pgRejected.Enabled = True
pgReports.Enabled = True
pgeManagement.Enabled = True

lstActiveJobs.Requery

End Sub
Private Sub cmdLaunch_Click()

Dim strSQL As String
Dim rst As Recordset
Dim rstL As Recordset
Dim strTarget As String
Dim strSourceFolder As String
Dim strSourceFile As String
Dim strPotentialFiles() As String
Dim intI As Integer
Dim intJobsRunning As Integer
Dim intPriorRuns As Integer
Dim blnProceed As Boolean
Dim LaunchFolder As Integer
Dim MonitorID As Long

ReDim Preserve strPotentialFiles(0)

Set rst = New Recordset
Set rstL = New Recordset

' Check if Launch is Enabled or not
strSQL = "select ConfigValue from dbo.CT_Config where ConfigItem = 'Launch Enabled'"
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

If rst.EOF Then
    MsgBox ("Launch Currently Disabled")
    blnProceed = False
Else
    If LCase(rst("ConfigValue")) = "true" Then
        blnProceed = True
    Else
        MsgBox ("Launch Currently Disabled")
        blnProceed = False
    End If
End If
rst.Close

If blnProceed Then
    ' Check if the file is actually populated
    strSQL = "Exec dbo.up_CT_FilePopulatedCheck " & lblJDRunID.Caption
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    If rst.EOF Then
        MsgBox ("Unable to determine File Size")
        blnProceed = False
    Else
        If rst("Populated") > 0 Then
            blnProceed = True
        Else
            MsgBox ("Source File appears to be empty - Please check and Cancel if true")
            blnProceed = False
        End If
    End If
    rst.Close
End If

' CTC 098 Additional Check for DPP Jobs
If blnProceed And LCase(lblJDJobType.Caption) = "dpp" Then
    strSQL = "Exec dbo.up_CT_DPP_LaunchCheck "
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    If rst.EOF Then
        MsgBox ("Unable to verify Cobra Environment Status for DPP jobs")
        blnProceed = False
    Else
        If rst("Enabled") Then
            blnProceed = True
        Else
            MsgBox ("DPP Launch on " & rst("Environment") & " Currently Disabled")
            blnProceed = False
        End If
    End If
    rst.Close
End If

If blnProceed Then
    ' check if any running jobs have completed
    Call CheckNeptuneStatus
    
    ' check how many jobs are actually currently running
    strSQL = "select Count(*) as JobsRunning from dbo.CT_JobRun where RunStatus = 'Running'"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    intJobsRunning = rst("JobsRunning")
    rst.Close
    
    If intJobsRunning < 10 Then ' #CTC032
        blnProceed = True
    ElseIf MsgBox("There are already " & Trim(str(intJobsRunning)) & " running, Do you wish to Launch This job?", vbYesNo) = vbYes Then
        blnProceed = True
    Else
        blnProceed = False
    End If
End If

If blnProceed Then
    
    ' #CTC013
    strSQL = "SELECT COUNT(*) AS PriorRuns FROM DataBureauDataLoadAudit.dbo.vw_CallTraceCurrentJobsV4 "
    strSQL = strSQL & "WHERE JobNo = '" & Trim(lblJDJobNo.Caption) & "' AND RunNo < " & Trim(lblJDRunNo.Caption) & " AND [Status] NOT IN ('Neptune Complete', 'In QC', 'Verified') "
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    intPriorRuns = rst("PriorRuns")
    rst.Close
    
    
    If intPriorRuns = 0 Then
        blnProceed = True
    'CTC120 - updated to prevent launching multiple jobs while previous run hasn't reached one of statuses like Neptune Complete, In QC, Verified
    Else: MsgBox (Trim(str(intPriorRuns)) & " previous run(s) for this job has not finished processing, for now you cannot launch this job")
        blnProceed = False
    End If
End If

If blnProceed Then
    ' first run of a job is processed through neptune, so just update the status
    If Val(lblJDRunNo.Caption) = 0 Then
        Call UpdateRunStatus(lblJDRunID.Caption, "Running", 0, "")
        Call SetActions("Running")
        blnProceed = False
    End If
End If

If blnProceed Then
    
    strTarget = AutoLoadFolder & Trim(lblJDJobNo.Caption) & "\"
    
    ' Determine if we need a Launch Folder
    LaunchFolder = Get_LaunchFolder(lblJDJobNo.Caption)
    
    If LaunchFolder Then
        strSourceFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Launch\*.*"
            
        ' can  we identify the file to load
        intI = 0
        strPotentialFiles(intI) = Dir(strSourceFolder)
        If strPotentialFiles(intI) = "" Then
            MsgBox ("Move file to Launch into Launch folder and try again")
            Exit Sub
        Else
            ' loop through all files from Launch folder
            Do
                intI = intI + 1
                If intI > UBound(strPotentialFiles) Then
                    ReDim Preserve strPotentialFiles(intI)
                End If
                strPotentialFiles(intI) = Dir
            Loop While Len(strPotentialFiles(intI))
            
            If intI > 1 Then
                MsgBox ("More than one file found in Launch folder, remove other files and try again")
                Exit Sub
            Else
                strSourceFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Launch\"
                strSourceFile = strPotentialFiles(0)
            End If
        End If
    Else
        strSourceFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Original\"
        strSourceFile = Trim(lblJDFileName.Caption)
    End If
        
    Set rst = New Recordset
    
    strSQL = "Select  j.JobNo as jobno, j.CustomerID, j.versioninc, j.stateid, s.StepStateID From neptune.dbo.Jis j "
    strSQL = strSQL & "inner join (select max(jisid) jisid from neptune.dbo.Jis where jobno='" & Trim(lblJDJobNo.Caption) & "') M "
    strSQL = strSQL & "on j.jisid = M.jisid inner join neptune.dbo.JisStep s on j.jisid=s.jisid where s.stepid = 204"
    
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    If rst.EOF Then
        MsgBox ("Run Not Launched, This job number isn't setup for Auto Launch")
        rst.Close
    ElseIf rst("StateID") <> 90 And rst("VersionInc") = 0 Then
        MsgBox ("Run Not Launched, Initial run of this job is not completed and verified")
        rst.Close
    ElseIf rst("StepStateID") <> 20 Then
        MsgBox ("Run Not Launched, Data still being imported for previous run")
        rst.Close
    Else
        rst.Close
    
        ' OK we need to wait check this launch hasn't been attempted but failed previously
        strSQL = " select count(*) GotEntry from neptune.dbo.MonitoredFiles where islocked =1 and username is null and Filename = '" & strSourceFile & "' and "
        strSQL = strSQL & " Folder like '%" & Trim(lblJDJobNo.Caption) & "%'"

        rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
        If rst("GotEntry") > 0 Then
            MsgBox ("Run Not Launched, There is already a partial launch for this run, contact Support")
            rst.Close
        Else
            rst.Close
            ' now launch the file
            If Not fso.FolderExists(strTarget) Then
                fso.CreateFolder (strTarget)
            End If
            ' CTC 102 Delete target if already exists
            If fso.FileExists(strTarget & strSourceFile) Then
                fso.DeleteFile strTarget & strSourceFile
                Call Sleep(5)
            End If
                
            fso.CopyFile strSourceFolder & strSourceFile, strTarget, False
               
            ' CTC 114 - New Launch Confirmation Code - Main Logic migrated to SQL
            Call CheckLaunch(strTarget, strSourceFile, strUserName)
            
        
        End If
    End If
End If

End Sub

Private Sub cmdLaunchFailed_Click()

Call UpdateRunStatus(lblJDRunID.Caption, "Launch Failed", 0, "")
Call SetActions("Launch Failed")

End Sub

' #CTC011
' hiding non-standard parameters from the tab and returning back to default values
Private Sub cmdLessOptions_Click()
    
    cmdMoreOptions.Visible = True
    cmdMoreOptions.SetFocus
    cmdLessOptions.Visible = False
    txtbx5.Visible = False
    txtbx6.Visible = False
    txtbx7.Visible = False
    txtbx9.Visible = False
    txtbx10.Visible = False
    txtbx11.Visible = False
    txtbx12.Visible = False
    txtbx13.Visible = False
    txtbx15.Visible = False
    cmb15.Visible = False
    txtbx16.Visible = False
    txtbx17.Visible = False
    txtbx18.Visible = False
    txtbx5.Value = "%"
    txtbx6.Value = ""
    txtbx7.Value = ""
    txtbx9.Value = ""
    txtbx10.Value = "0"
    txtbx11.Value = "1"
    txtbx12.Value = ""
    txtbx13.Value = ""
    cmb15.Value = "pdf"
    txtbx16.Value = "4"
    txtbx17.Value = "1"
    txtbx18.Value = "0"
    
End Sub


' #CTC011
' button for exiting the management tab
Private Sub cmdManagementBack_Click()

pgFileList.SetFocus
pgeManagement.Visible = False
cmdAddJob.Enabled = True
Dim lngGrey As Long
lngGrey = RGB(150, 150, 150)
lblNeptuneClientNameValue.Visible = False
lblJobNumbValue.Visible = False
lblClientStatusValue.Visible = False
lblComparabilityValue.Visible = False
lblNeptuneClientName.ForeColor = lngGrey
lblJobNumb.ForeColor = lngGrey
lblClientStatus.ForeColor = lngGrey
lblComparability.ForeColor = lngGrey
cmdAddNewJob.Enabled = False
cmdCancelAddNewJob.Enabled = False
cmbJobs.Value = "Select..."
chkDefaultValues.Visible = False
lblDefVal.Visible = False
txtbx3.Visible = False
txtbx4.Visible = False
txtbx5.Visible = False
txtbx6.Visible = False
txtbx7.Visible = False
cmb8.Visible = False
txtbx8.Visible = False
txtbx8.Visible = False
txtbx9.Visible = False
txtbx10.Visible = False
txtbx11.Visible = False
txtbx12.Visible = False
txtbx13.Visible = False
txtbx14.Visible = False
cmb15.Visible = False
txtbx15.Visible = False
txtbx16.Visible = False
txtbx17.Visible = False
txtbx18.Visible = False
chkDefaultValues.Enabled = False
txtbx3.Enabled = False
txtbx4.Enabled = False
txtbx5.Enabled = False
txtbx6.Enabled = False
txtbx7.Enabled = False
cmb8.Enabled = False
txtbx8.Enabled = False
txtbx9.Enabled = False
txtbx10.Enabled = False
txtbx11.Enabled = False
txtbx12.Enabled = False
txtbx13.Enabled = False
txtbx14.Enabled = False
cmb15.Enabled = False
txtbx15.Enabled = False
txtbx16.Enabled = False
txtbx17.Enabled = False
txtbx18.Enabled = False
cmdMoreOptions.Visible = False
cmdMoreOptions.Enabled = False
cmdLessOptions.Visible = False

End Sub

' #CTC011
' showing non-standard parameters from the tab
Private Sub cmdMoreOptions_Click()
    
    cmdLessOptions.Visible = True
    cmdLessOptions.SetFocus
    cmdMoreOptions.Visible = False
    txtbx5.Visible = True
    txtbx6.Visible = True
    txtbx7.Visible = True
    txtbx9.Visible = True
    txtbx10.Visible = True
    txtbx12.Visible = True
    txtbx13.Visible = True
    txtbx15.Visible = True
    cmb15.Visible = True
    txtbx16.Visible = True
    txtbx17.Visible = True
    txtbx18.Visible = True
    
End Sub

Private Sub cmdProcess_Click()

' routine to link a file to a CallTrace job
Call LinkFile

End Sub

Private Sub cmdProcessedJob_Click()
' Neptune processing has completed

Dim strAutomationFolder As String
Dim strOutputFolder As String
Dim strSQL As String
Dim Continue As Boolean

Call CheckNeptuneStatus

If LCase(lblJDRunStatus.Caption) <> "neptune complete" Then
    MsgBox ("Wait for job to complete in Neptune")
Else
    Call CopyFromAutoLoadFolder(Trim(lblJDJobNo.Caption), Trim(lblJDRunNo.Caption))
   
    Call UpdateRunStatus(lblJDRunID.Caption, "In QC", 0, "")
    Call SetActions("In QC")
End If

End Sub
Sub CopyFromAutoLoadFolder(JobNumber As String, RunNumber As String)

    Dim strAutomationFolder As String
    Dim strOutputFolder As String

    strOutputFolder = RootJobFolder & JobNumber & "_" & RunNumber & "\Output\"
    strAutomationFolder = AutoLoadFolder & JobNumber & "\" & JobNumber & "_" & RunNumber & "\Results\"
    
    If fso.FolderExists(strAutomationFolder) Then
        If Dir(strAutomationFolder & "*.*") <> "" Then
            fso.MoveFile strAutomationFolder & "*.*", strOutputFolder
        End If
    End If
    
End Sub


Private Sub cmdProgress_Click()
' Show the Job Detail page, populating the details with the entry selected from the list

Dim intRunID As Long

'have we got an entry selected
If Not IsNull(lstActiveJobs.Value) Then
    
    intRunID = lstActiveJobs.Value
    Call Progressjob(intRunID)

End If

End Sub

Private Sub cmdQCJob_Click()

'On Local Error GoTo cmdProcessedJob_Click_Error
Dim strAutomationFolder As String
Dim strOutputFolder As String
Dim strSQL As String
Dim Continue As Boolean
Dim MappingsOK As Boolean
Dim rst As Recordset
Set rst = New Recordset

If chkAutoCheckFiles.Value Then
    Continue = True
ElseIf MsgBox("Skip File Volume Checks?", vbOKCancel) = vbOK Then
    Continue = True
Else
    Continue = False
End If

If Continue Then
    
    pgJobDetail.Enabled = False
    
    ' CTC 068
    MappingsOK = CheckMappings

    If MappingsOK Then
    
        ' OK now check the output files for nulls etc
        Call CheckFiles
        
        ' Check for post-processing, if required, execute it.
        ' When successful, set to verified, otherwise set to failed
        If (ExecutePostProcessing) Then
            pgJobDetail.Enabled = True
            Call UpdateRunStatus(lblJDRunID.Caption, "Verified", 0, "")
            Call SetActions("Verified")
        Else
            pgJobDetail.Enabled = True
            Call UpdateRunStatus(lblJDRunID.Caption, "Failed", 10, "") ' 10 = Post-processing
            Call SetActions("Failed")
        End If
    Else
        pgJobDetail.Enabled = True
        Call UpdateRunStatus(lblJDRunID.Caption, "Failed", 11, "")
        Call SetActions("Failed")
    End If
    
End If

End Sub

Function CheckMappings()
' CTC 068 - check for incorrect mappings

Dim strSQL As String
Dim result As Boolean
Dim rst As Recordset
Set rst = New Recordset

result = False

strSQL = "select [dbo].[fn_CT_MappingCheck] ('" & lblJDJobNo.Caption & "'," & lblJDRunNo.Caption & ")  MapResult"
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

If rst.EOF Then
    MsgBox "Mappings Check Failed - No Results Found"
Else
    Select Case rst("MapResult")
    Case "OK"
        result = True
    Case "Incorrect Mappings Found"
        MsgBox "Mappings Check Failed - Check Mappings in Neptune"
    Case Else
        MsgBox "Mappings Check Failed - " & rst("MapResult")
    End Select
End If
rst.Close

CheckMappings = result

End Function

' #CTC020
Private Sub cmdRefreshCTFeedback_Click()

Call PopulateCTFeedbackList

End Sub
Private Sub cmdRefreshDataIn_Click()

'TOT 184 Passing parameters to the script
Dim Script_WithArgs
Dim oShell
Dim retVal
Dim appCmd
Dim doubleQuotes As String
Dim rst As dao.Recordset
Dim SQL As String
Dim dbLocal As dao.Database
Dim ActiveServer As String
Dim connectionMode As String
Dim waitOnReturn As Boolean: waitOnReturn = True

    doubleQuotes = """"
    
    'Get the current connection name
    Set dbLocal = CurrentDb
    SQL = "Select * from Config where enabled"
    Set rst = dbLocal.OpenRecordset(SQL)
    rst.MoveLast
    ActiveServer = LCase(rst("ConnectionString"))
    connectionMode = LCase(rst("Mode"))
    rst.Close

    pgFileList.Enabled = False

    ' New Version - Execute the PowerShell script to find files
    Set oShell = CreateObject("Wscript.Shell")
    Script_WithArgs = doubleQuotes & PS_Script & doubleQuotes & " -SQLServer " & ActiveServer & " -ModeType " & connectionMode
    appCmd = "powershell.exe -ExecutionPolicy Unrestricted -file " & Script_WithArgs
    retVal = oShell.Run(appCmd, 0, waitOnReturn)

    pgFileList.Enabled = True
        
    ' refresh view
    lstFileView.Requery
    
    MsgBox ("Refresh Complete")
    
End Sub

Private Sub cmdReject_Click()
' In List view the selected file is determined not to be CallTrace, flag this in the database

Dim lngFileID As Long
Dim strSQL As String

lngFileID = lstFileView.Value

If Not IsNull(lngFileID) Then
    If MsgBox("Are you sure you you wish to mark the selected file as Non-CallTrace?", vbYesNo) = vbYes Then

        'add file to the rejects table
        strSQL = "insert into dbo.CT_RejectedFiles(FileID, FileSource,RejectedBy,RejectedDate) "
        strSQL = strSQL & "select fileid, source, '" & strUserName & "',getdate() from "
        strSQL = strSQL & "dbo.vw_CallTraceFilesToDisplay_New where fileid = " & Trim(str(lngFileID))
        
        db.Execute (strSQL)
        
        lstFileView.Requery
        lstRejected.Requery
    End If
End If

End Sub

Private Sub cmdRestartJob_Click()

    ' #CTC028 #CTC034
    Dim LastStep As String
    Dim strSQL As String
    Dim rst As Recordset
    Set rst = New Recordset
    strSQL = "WITH CTE_LastFailedStatus AS (SELECT TOP 1 * FROM DataBureauDataLoadAudit.dbo.CT_RunStatusLog "
    strSQL = strSQL & "WHERE CT_RunID = '" & lblJDRunID.Caption & "' AND (CT_Status = 'Failed' OR CT_Status = 'Check Job') "
    strSQL = strSQL & "ORDER BY UpdateDate DESC) "
    strSQL = strSQL & "SELECT TOP 1 CTRS.CT_Status FROM DataBureauDataLoadAudit.dbo.CT_RunStatusLog CTRS "
    strSQL = strSQL & "JOIN CTE_LastFailedStatus CLFS ON CLFS.CT_RunID = CTRS.CT_RunID "
    strSQL = strSQL & "WHERE CTRS.UpdateDate < CLFS.UpdateDate "
    strSQL = strSQL & "ORDER BY CTRS.UpdateDate DESC "
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    LastStep = Trim(rst("CT_Status"))
    rst.Close
    
    If (LastStep = "Pre-Processing") Then
        Call UpdateRunStatus(lblJDRunID.Caption, "Pre-Processing", 0, "")
        Call SetActions("Pre-Processing")
    Else
        Call UpdateRunStatus(lblJDRunID.Caption, "Running", 0, "")
        Call SetActions("Running")
    End If

End Sub


Private Sub cmdSendReport_Click()

    Dim strSQL As String
    Dim strSubject As String
    Dim strBody As String
    Dim strAttachFolder As String
    Dim strSuppliedFile As String
    Dim strSentFile As String
    Dim rst As Recordset
    Dim emailTo As String
    Dim EmailCC As String
    Dim strTableStdCSS As String
    Dim strTDStdCSS As String
    Dim strTHStdCSS As String
        
    On Error Resume Next
    
    Set rst = New Recordset
    
    ' Retrieve recipients
    rst.Close
    strSQL = "select * from dbo.vw_CT_EmailDefaults"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    While Not rst.EOF
    
        Select Case UCase(Trim(rst("EmailUse")))
        Case UCase("Report To")
            emailTo = emailTo & Trim(rst("EmailAddress")) & ";"
        Case UCase("Report CC")
            EmailCC = EmailCC & Trim(rst("EmailAddress")) & ";"
        Case Else
            ' ignore
        End Select
        
        rst.MoveNext
    Wend
    rst.Close
           
    strSubject = "CallTrace Status Report"
    
    ' Set standard CSS strings
    strTableStdCSS = "border-collapse:collapse;font-size:11pt;font-family:arial,helvetica,sans-serif;"
    strTHStdCSS = "text-align:left;margin:0px;padding:5px;padding-left:10px;padding-right:10px;background-color:#00A6CA;color:#ffffff;text-align:left;"
    strTDStdCSS = "margin:0px;padding:5px;padding-left:10px;padding-right:10px;border-bottom-style:solid;border-width:1px;border-color:#888888;"
    
    ' build up the email body
    strBody = "<html><body style = ""font-family:scene std,arial,helvetica,sans-serif;font-size:11pt;""><p>Hello</p><h3 style = ""margin-top:40px;"">Next Delivery Due</h3>"
    strBody = strBody & ""
    
    strSQL = "select * from dbo.vw_CT_NextDueJob"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

    If rst.EOF Then
        strBody = strBody & "<p>No Jobs Outstanding</p>"
    Else
        
        strBody = strBody & "<table style = """ & strTableStdCSS & """>"
        strBody = strBody & "   <tr>"
        ' CTC 098 - Add new Job Type value
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:90px;min-width:90px;"">Job Type</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:250px;min-width:250px;"">Client Name</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:110px;min-width:110px;"">Job Number</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:75px;min-width:75px;"">Run No</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:115px;min-width:115px;"">Due Date</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:135px;min-width:135px;"">Status</th>"
        strBody = strBody & "   </tr>"
        
        strBody = strBody & "   <tr>"
        ' CTC 098 - Add new Job Type value
        strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("JobType") & "</td>"
        strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("ClientName") & "</td>"
        strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("Job_Number") & "</td>"
        strBody = strBody & "       <td style = """ & strTDStdCSS & "text-align:right;"">" & rst("RunNo") & "</td>"
        strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("DueByDate") & "</td>"
        strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("RunStatus") & "</td>"
        strBody = strBody & "   </tr>"
        strBody = strBody & "</table>"
    End If
   rst.Close
    
    strBody = strBody & "<h3 style = ""margin-top:40px;"">Todays Delivery Summary</h3>"
    
    strSQL = "select * from dbo.vw_CT_DailyReportDelivery"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

    If rst.EOF Then
        strBody = strBody & "<p>No Jobs To Deliver</p>" & crlf & crlf
    Else
        strBody = strBody & "<table style = """ & strTableStdCSS & """>"
        strBody = strBody & "   <tr>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & """>Delivery Status</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & """>Count</th>"
        strBody = strBody & "   </tr>"
        
        While Not rst.EOF
            strBody = strBody & "   <tr>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("DeliveryStatus") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & "text-align:right;"">" & rst("Count") & "</td>"
            strBody = strBody & "   </tr>"
            rst.MoveNext
        Wend
        strBody = strBody & "</table>"
    End If
    rst.Close
    
    strBody = strBody & "<h3 style = ""margin-top:40px;"">Error Details</h3>"
    
    strSQL = "select * from dbo.vw_CT_DailyReportErrors"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

    If rst.EOF Then
        strBody = strBody & "<p>No Errors</p>"
    Else
        strBody = strBody & "<table style = """ & strTableStdCSS & """>"
        strBody = strBody & "   <tr>"
        ' CTC 098 - Add new Job Type value
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:90px;min-width:90px;"">Job Type</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:250px;min-width:250px;"">Client Name</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:110px;min-width:110px;"">Job Number</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:75px;min-width:75px;"">Run No</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:200px;min-width:200px;"">Error Type</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & """>TTP</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:115px;min-width:115px;"">Time</th>"
        strBody = strBody & "   </tr>"
        
        While Not rst.EOF
            strBody = strBody & "   <tr>"
            ' CTC 098 - Add new Job Type value
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("JobType") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("ClientName") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("Job_Number") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & "text-align:right;"">" & rst("RunNo") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("ErrorType") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("TTP") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("ErrorTime") & "</td>"
            strBody = strBody & "   </tr>"
            rst.MoveNext
        Wend
        strBody = strBody & "</table>"
    End If
    rst.Close

    strBody = strBody & "<h3 style = ""margin-top:40px;"">Daily Summary</h3>"
    
    strSQL = "select * from vw_CT_DailyReport_1"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

    If rst.EOF Then
        strBody = strBody & "<p>No Jobs To Deliver</p>"
    Else
        strBody = strBody & "<table style = """ & strTableStdCSS & """>"
        strBody = strBody & "   <tr>"
        ' CTC 098 - Add new Job Type value
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:90px;min-width:90px;"">Job Type</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:250px;min-width:250px;"">Client Name</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:110px;min-width:110px;"">Job Number</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:75px;min-width:75px;"">Run No</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:115px;min-width:115px;"">Due Date</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:135px;min-width:135px;"">Run Status</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:115px;min-width:115px;"">Delivered</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & """>Errors</th>"
        strBody = strBody & "       <th style = """ & strTHStdCSS & "width:80px;min-width:80px;"">Delivery</th>"
        strBody = strBody & "   </tr>"
        
        While Not rst.EOF
            strBody = strBody & "   <tr>"
            ' CTC 098 - Add new Job Type value
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("JobType") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("ClientName") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("Job_Number") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & "text-align:right;"">" & rst("RunNo") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("DueDate") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("RunStatus") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("Delivered") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & "text-align:right;"">" & rst("ErrorCount") & "</td>"
            strBody = strBody & "       <td style = """ & strTDStdCSS & """>" & rst("DeliveryStatus") & "</td>"
            strBody = strBody & "   </tr>"
            rst.MoveNext
        Wend
        strBody = strBody & "</table>"
    End If
    rst.Close

    strBody = strBody & "<p>Regards</p></html>"
    
    If Not sendEmail(emailTo, strSubject, strBody, EmailCC) Then
        MsgBox ("Unable to send report, issues with SMTP email - escalate to EFT-CD team")
    End If
    On Error GoTo 0

End Sub

Private Sub SetupJob(JobRunStatus As String, JobNumber As String, RunNumber As Integer, FileFolder As String, FileName As String, JobClient As String, RunID As String)
' OK this button is to set the job up by creating the folder structure and copying the source file
'CTC 077 Copy(Move) files from client location to job location using DTP
'TOT 217 Create seperate DTP action xmls instead of Process XML

On Local Error GoTo cmdSetupJob_Error

Dim strRootFolder As String
Dim strJobFolder As String
Dim LaunchFolder As Integer
Dim SQL As String
Dim rst As Recordset

Dim nodeStep As Integer
Dim InterimSubFolder As String
Dim GUIDString As String
Dim PGP_Input As String
Dim PGPTempFolder As String
Dim DecryptionAdded As Boolean
Dim DTPProcessing As String

Dim FileCopied As Boolean
Dim MaxProcessingTime As Integer
Dim StartTime As Double
Dim SecondsElapsed As Double

Dim SaveLocation As String
Dim DTPToLoad As String
Dim ActionListNames As String
Dim FirstActionPath As String

Dim DeleteSource As Integer
Dim sqlDeleteSrc As String

FileCopied = False

If LCase(JobRunStatus) = "logged" Then
    
    ' Determine if we need a Launch Folder
    LaunchFolder = Get_LaunchFolder(JobNumber)
    
    SQL = "SELECT LaunchFolder FROM DataBureauDataLoadAudit.dbo.CT_Jobs where Job_Number='" & JobNumber & "'"

    Set rst = New Recordset
    rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly
    If rst.EOF Then
        LaunchFolder = 0
    Else
        LaunchFolder = rst("LaunchFolder")
    End If
    rst.Close
    
    'EFT 734 - Specific Jobs when source files should always be moved
 
    sqlDeleteSrc = "SELECT ISNULL(DeleteSource, 0) as DeleteSource FROM DataBureauDataLoadAudit.dbo.CT_Jobs where Job_Number='" & JobNumber & "'"
    rst.Open sqlDeleteSrc, db, adOpenForwardOnly, adLockReadOnly
    DeleteSource = rst("DeleteSource")
    rst.Close

    'Set the job folder name
    strJobFolder = RootJobFolder & JobNumber & "_" & RunNumber
    
    ' CTC 089 - Different method of determining whether the file is local or DTP copy is required
    If IsSourceFileLocal(FileFolder) Then
        'Create the job folder and it's subfolders
        fso.CreateFolder (strJobFolder)
        fso.CreateFolder (strJobFolder & "\Original")
        If LaunchFolder Then
            fso.CreateFolder (strJobFolder & "\Launch")
        End If
        fso.CreateFolder (strJobFolder & "\Output")
        fso.CreateFolder (strJobFolder & "\Reports")
        fso.CreateFolder (strJobFolder & "\Sent")
        fso.CreateFolder (strJobFolder & "\Old")
        fso.MoveFile FileFolder & FileName, strJobFolder & "\Original\"
    Else
        'Needs copying from EFT using Data Transfer Process
        'Debug.Print Now(); " Time when Setup Button was clicked"
        
        'Get the location for saving the DTP XML files
        SQL = "select ConfigValue from CT_Config where ConfigItem = 'DTPPendingFolder'"
        rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly
        SaveLocation = rst("ConfigValue")
        rst.Close
        
        'Get the location for moving the DTP XML action ToLoad folder
        SQL = "select ConfigValue from CT_Config where ConfigItem = 'DTPToLoadFolder'"
        rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly
        DTPToLoad = rst("ConfigValue")
        rst.Close

        InterimSubFolder = InterimFolder & JobNumber & "_" & RunNumber
        'Create subfolder in interim location
        If fso.FolderExists(InterimSubFolder) Then
           fso.DeleteFolder (InterimSubFolder)
        End If
        fso.CreateFolder (InterimSubFolder)
        
        'Generate GUID string for DTP XML
        GUIDString = GUID.CreateGuidString
        
        'Iterating DTP action step sequence from 1
        nodeStep = 1
        'Check if decryption is required
        DecryptionAdded = False
        SQL = "select PGP_Input from ct_jobs where Job_Number = '" & JobNumber & "'"
        Set rst = New Recordset
        rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly
        If Not rst.EOF Then
          If IsNull(rst("PGP_Input")) Then
              PGP_Input = "0"
          ElseIf rst("PGP_Input") = "False" Then
              PGP_Input = "0"
          ElseIf rst("PGP_Input") = "" Then
              PGP_Input = "0"
          ElseIf rst("PGP_Input") = "0" Then
              PGP_Input = "0"
          Else
              PGP_Input = rst("PGP_Input")
              DecryptionAdded = True
          End If
        End If
        rst.Close
                
        'Debug.Print Now(); " Collected info for DTP request"
                
        'Create decryption node in DTP Request file
        If DecryptionAdded Then
           'Set temp folder for PGP decryption
           PGPTempFolder = PGPTemporaryFolder & GUIDString
           'Currently as the decryption key is same for all the PGP inbound files we need to set decryption key to empty value for Auto decryption folder
           PGP_Input = ""
           Call DTPXML.CreateDecryptionNode(GUIDString, ActionListNames, SaveLocation, nodeStep, FileName, FileFolder, PGPTempFolder, PGP_Input, JobNumber, JobClient)
           
           'The filename will no longer have .pgp extension, so need to remove that
           If InStr(LCase(FileName), ".pgp") > 0 Then FileName = Replace(FileName, ".pgp", "")
            'Or it may have .gpg extension
           If InStr(LCase(FileName), ".gpg") > 0 Then FileName = Replace(FileName, ".gpg", "")
           
           'Copy the file from temporary PGP location to the interim folder
           Call DTPXML.CreateCopyNode(GUIDString, ActionListNames, SaveLocation, nodeStep, PGPTempFolder, InterimSubFolder, FileName, JobNumber, JobClient)
           
           'After the file has been copied, we can delete the temporary PGP location
           Call DTPXML.CreateDeletionNode(GUIDString, ActionListNames, SaveLocation, nodeStep, PGPTempFolder, JobNumber, JobClient)
           
        Else
        'Create DTP request node to copy(move) files from input location to interim location
        'EFT 734 - Specific Jobs when source files should always be moved
            If DeleteSource = 1 Then
                Call DTPXML.CreateMoveNode(GUIDString, ActionListNames, SaveLocation, nodeStep, FileFolder, InterimSubFolder, FileName, JobNumber, JobClient)
            ElseIf InStr(LCase(FileFolder), "\production\data in\calltrace\") > 0 Or InStr(LCase(FileFolder), "\Neptune\CallTrace\InTouch\") > 0 Then
                Call DTPXML.CreateMoveNode(GUIDString, ActionListNames, SaveLocation, nodeStep, FileFolder, InterimSubFolder, FileName, JobNumber, JobClient)
            Else
                Call DTPXML.CreateCopyNode(GUIDString, ActionListNames, SaveLocation, nodeStep, FileFolder, InterimSubFolder, FileName, JobNumber, JobClient)
            End If
        End If

        'Create DTP request to create a trigger file when file copy has been complete using "BespokeCommand" with "out-file", inside the interimSubFolder
        Call DTPXML.CreateTriggerNode(GUIDString, ActionListNames, SaveLocation, nodeStep, InterimSubFolder, JobNumber, RunNumber)
        
        'Move the first action into the ToLoad folder
        FirstActionPath = Split(ActionListNames, ";")(0)
        fso.MoveFile FirstActionPath, DTPToLoad

        'Debug.Print Now(); " Created DTP action xmls"
        
        'Start the timer to check how long DTP process has been running
        StartTime = Timer
        MaxProcessingTime = 120
        
        'Loop until completed transfer trigger file is found - meaning the end of the copy
        While Not fso.FileExists(InterimSubFolder & "\" & JobNumber & "_" & RunNumber & ".trg")
            'Check the elapsed time
            SecondsElapsed = Round(Timer - StartTime, 2)
            
            'Check if any actions triggers were moved to the failed folder
            'Beggining and ending of action trigger names can differ, so need a wildcard to check if it exists
            If (Dir(DTPFailedFolder + "*" & GUIDString & "*") <> vbNullString) Then
                MsgBox "Request to copy the file failed" & vbCrLf & "Please contact Technical Operator."
                Exit Sub
            End If
            
           'It shouldn't take longer than 2 minutes, if it does it probably means DTP process failed to copy the file
            If SecondsElapsed > MaxProcessingTime Then
                MsgBox ("Request to copy the file from client to Job folder exceeded it's time limit - " & (MaxProcessingTime / 60) & " minutes")
                
                'Allow users to extend the time of the copy if time limit is exceeded
                If (MsgBox("Extend time limit by another minute?", vbYesNo) = vbYes) Then
                    MaxProcessingTime = MaxProcessingTime + 60
                Else
                    Exit Sub
                End If
            End If
            
        Wend
        ' Debug.Print Now(); " Detected trigger created by DTP"
        
        'Create required job folders
        fso.CreateFolder (strJobFolder)
        fso.CreateFolder (strJobFolder & "\Original")
        If LaunchFolder Then
            fso.CreateFolder (strJobFolder & "\Launch")
        End If
        fso.CreateFolder (strJobFolder & "\Output")
        fso.CreateFolder (strJobFolder & "\Reports")
        fso.CreateFolder (strJobFolder & "\Sent")
        fso.CreateFolder (strJobFolder & "\Old")
        
        'Third timer
        ' Debug.Print Now(); " Created job folders"
        
        'Move file from interim location to Job folder using CTC
        fso.MoveFile InterimSubFolder & "\" & FileName, strJobFolder & "\Original\"
        
        ' Debug.Print Now(); " Moved the file from interim to job folder"
    
        'Delete the interim subfolder along the completed transfer trigger
        fso.DeleteFolder (InterimSubFolder)
        ' Debug.Print Now(); " Deleted the interim folder"
    End If
    
    FileCopied = True
    
    ' check if we have a file with a leading space in the name as this can cause errors. If RTrim(lblJDFileName.Caption) <> Trim(lblJDFileName.Caption) Then
    If RTrim(FileName) <> Trim(FileName) Then
        ' no leading spaces
        fso.MoveFile strJobFolder & "\Original\" & RTrim(FileName), strJobFolder & "\Original\" & Trim(FileName)
        FileName = Trim(FileName)
    End If
    ' Debug.Print Now(); " Checked and/or removed leading spaces"
        
    JobRunStatus = "Pre-Processing"
    
    Call UpdateRunStatus(RunID, JobRunStatus, 0, "")
    ' Debug.Print Now(); " Updated run status"
        
    Call SetActions(JobRunStatus)
    ' Debug.Print Now(); " Console actions set"
    MsgBox ("Folders Created and Source File Copied")

End If

Exit Sub


cmdSetupJob_Error:
    If FileCopied Then
        MsgBox "Error occured before copying the file, make sure the file exists and try again."
        MsgBox "Error: " & Err.Description
        Exit Sub
    Else
        MsgBox "Error occured after copying the file to job folder. Contact Technical Operator."
        MsgBox "Error: " & Err.Description
        Exit Sub
    End If


End Sub
Private Function IsSourceFileLocal(FolderPath As String) As Boolean
' CTC 089 - Check if the path is local or requires DTP

Dim SQL As String
Dim rst As Recordset
Dim Enabled As Boolean

Set rst = New Recordset
SQL = "exec [dbo].[up_CT_CheckLocalFile] '" & Trim(FolderPath) & "'"
rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly

If rst.EOF Then
    IsSourceFileLocal = False
ElseIf rst("Success") = 0 Then
    IsSourceFileLocal = False
Else
    IsSourceFileLocal = True
End If

rst.Close

End Function

Private Sub cmdSwitchCobra_Click()

Dim rst As Recordset
Dim strSQL As String
Dim Environment As String

' CTC 098 - Update status of DPP Environment
strSQL = "Exec dbo.up_CT_DPP_LaunchCheck"
Set rst = New Recordset
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

If rst.EOF Then
    MsgBox ("Unable to switch Environment")
Else
    Environment = UCase(rst("Environment"))
    rst.Close
    Select Case Environment
    Case "VAL"
        db.Execute ("EXEC [Neptune].[dbo].[up_DPP_SetBatchWorkflowEndpoint] 'CRL'")
    Case "CRL"
        db.Execute ("EXEC [Neptune].[dbo].[up_DPP_SetBatchWorkflowEndpoint] 'VAL'")
    Case Else
        MsgBox ("Unable to switch Environment")
    End Select
End If
    
Call ShowDPPStatus

End Sub
Sub ShowDPPStatus()
' CTC 098 - Update status of DPP Environment

Dim rst As Recordset
Dim strSQL As String

strSQL = "Exec dbo.up_CT_DPP_LaunchCheck"
Set rst = New Recordset
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

If rst.EOF Then
    lbl_DPPEnvironment.Caption = "DPP Cobra Environment Not Determined"
    cmdSwitchCobra.Enabled = False
ElseIf rst("Enabled") Then
    lbl_DPPEnvironment.Caption = "Default Cobra Environment is " & rst("Environment") & " - Currently Enabled"
    cmdSwitchCobra.Enabled = True
Else
    lbl_DPPEnvironment.Caption = "Default Cobra Environment is " & rst("Environment") & " - Currently Disabled"
    cmdSwitchCobra.Enabled = True
End If
rst.Close
    
End Sub

Private Sub cmdToggleLaunch_Click()

Dim SQL As String
Dim rst As Recordset
Dim Enabled As Boolean

Set rst = New Recordset

' Check if Launch is Enabled or not
SQL = "select ConfigValue from dbo.CT_Config where ConfigItem = 'Launch Enabled'"
rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly

If rst.EOF Then
    Enabled = False
Else
    If LCase(rst("ConfigValue")) = "true" Then
        Enabled = True
    Else
        Enabled = False
    End If
End If
rst.Close

If Enabled Then
    If MsgBox("Launch Currently Enabled, Disable Launching?", vbYesNo) = vbYes Then
        SQL = "update dbo.CT_Config set ConfigValue = 'False' where ConfigItem = 'Launch Enabled'"
        db.Execute (SQL)
        cmdToggleLaunch.Caption = "Enable Launch"
    End If
Else
    If MsgBox("Launch Currently Disabled, Enable Launching?", vbYesNo) = vbYes Then
        SQL = "update dbo.CT_Config set ConfigValue = 'True' where ConfigItem = 'Launch Enabled'"
        db.Execute (SQL)
        cmdToggleLaunch.Caption = "Disable Launch"
    End If
End If

End Sub

Private Sub cmdUnReject_Click()

' In Rejected List view the selected file is determined that it shouldn't be Rejected
Dim lngRejectID As Long
Dim strFileName As String
Dim strFolder As String
Dim blnReject As Boolean
Dim strSQL As String

If Not IsNull(lstRejected.Value) Then

    lngRejectID = lstRejected.Value
    
    If MsgBox("Are you sure you you wish to remove this file from the Rejected List?", vbYesNo) = vbYes Then
        blnReject = True
    Else
        blnReject = False
    End If
        
    If blnReject Then
        ' Find the entry in the Rejected File List
        strSQL = "Update dbo.CT_RejectedFiles set UnRejectedBy = '" & strUserName & "',"
        strSQL = strSQL & "UnRejectedDate = getdate() "
        strSQL = strSQL & "where id = " & Trim(str(lngRejectID))
        
        db.Execute (strSQL)
        lstFileView.Requery
        lstRejected.Requery
    End If
End If

End Sub

' #CTC011
' epmtying all values from combobox and listing with job numbers according to query results
Private Sub listJobsInCmb()
 
cmbJobs.RowSource = ""
Dim SQLRecentUnAlocJobs As String

SQLRecentUnAlocJobs = "SELECT * FROM DataBureauDataLoadAudit.dbo.vw_CT_NewJobs AS vCNJ ORDER BY vCNJ.JisID ASC"
 
Dim rst As Recordset
Set rst = New Recordset
rst.Open SQLRecentUnAlocJobs, db, adOpenForwardOnly, adLockReadOnly
If rst.EOF Then
   rst.Close
Else
   While Not rst.EOF
      SQLRecentUnAlocJobs = Trim(rst("JobNo"))
      cmbJobs.AddItem (Trim(SQLRecentUnAlocJobs))
      rst.MoveNext
   Wend
   rst.Close
End If
cmbJobs.Value = "Select..."

End Sub

' #CTC011
' activating the management tab
Private Sub cmdAddJob_Click()
Dim rst As Recordset
Dim strSQL As String

Call listJobsInCmb
pgeManagement.Visible = True
pgeManagement.SetFocus

' CTC 098 - Update status of DPP Environment
Call ShowDPPStatus

cmdAddJob.Enabled = False

End Sub
Sub LoadConfiguration()

DTPProcessingFolder = GetConfigValue("DTPProcessingFolder")
ClientEmailFolder = GetConfigValue("ClientEmailFolder")
RootJobFolder = GetConfigValue("RootJobFolder")
AutoLoadFolder = GetConfigValue("AutoLoadFolder")
ArchiveFolder = GetConfigValue("ArchiveFolder")
InterimFolder = GetConfigValue("InterimFolder")
FileExistsTriggerFolder = GetConfigValue("FileExistsTriggerFolder")
DataInCallTraceFolder = GetConfigValue("DataInCallTraceFolder")
PGPTemporaryFolder = GetConfigValue("PGPTemporaryFolder")
EmailLogFolder = GetConfigValue("EmailLogFolder")
DTPFailedFolder = GetConfigValue("DTPFailedFolder")
InTouchFolder = GetConfigValue("InTouchFolder")
PS_Script = GetConfigValue("ScriptPath")

Debug_Enabled = GetConfigValue("Debug_Enabled")
DebugOutput = GetConfigValue("DebugOutput")

' TOT 334 - Read the zip details from config and check which we have - 7Zip or Winzip
PathZipProgram = GetConfigValue("7ZipPath")
If fso.FileExists(PathZipProgram) Then
    ZipCompress = GetConfigValue("7ZipCompress")
    ZipListFlag = GetConfigValue("7ZipList")
Else
    PathZipProgram = GetConfigValue("WinZipPath")
    If fso.FileExists(PathZipProgram) Then
        ZipCompress = GetConfigValue("WinZipCompress")
        ZipListFlag = GetConfigValue("WinZipList")
    Else
        MsgBox ("Unable to detect compression tools (7Zip or WinZip) - Job Delivery will be unavailable")
    End If
End If

End Sub
Function GetConfigValue(ConfigItem As String)

Dim strSQL As String
Dim rst As Recordset

Set rst = New Recordset

strSQL = "select ConfigValue from CT_config where configItem = '" + ConfigItem + "'"
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

If rst.EOF Then
    GetConfigValue = "Not Found"
    MsgBox "The configuration for " + ConfigItem + " could not be loaded. Please restart the console."
Else
    GetConfigValue = rst("ConfigValue")
End If

rst.Close

End Function


Private Sub Form_Load()

Dim strSQL As String
Dim rst As Recordset
Dim ts As Object
Dim strLineIn As String
Dim SQLTime As Date
Dim WindowsTime As Date

'CBC 052 Setting server connection based on Config table
ConnectionString = SetDBConnection

Set rst = New Recordset

Set db = New Connection
db.ConnectionString = ConnectionString
db.Open

db.CommandTimeout = 360

Set fso = CreateObject("scripting.FileSystemObject")

'CBC 052 Load the configuration paths from SQL all at once
Call LoadConfiguration

crlf = Chr(13) & Chr(10)
stab = "|"
Me.chkLaunchJob.Value = True


strUserName = GetWindowsUserName

pgFileList.Enabled = True
pgRejected.Enabled = True
pgRejected.Enabled = True
pgJobDetail.Visible = False
pgJobDetail.Enabled = False
pgLogError.Visible = False
pgLogError.Enabled = False
pgRunEdit.Enabled = False
pgRunEdit.Visible = False
pgCheckError.Visible = False

If blnIsTeamLeader() Then
    cmdAddJob.Enabled = True
Else
    cmdAddJob.Enabled = False
End If

lstFileView.Enabled = True

' before starting check that the software is the latest version
strSQL = "select configvalue as Version, getdate() as SQLDate from CT_config where configItem = 'CallTraceConsole Version'"
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

' if not proceed with all pages disabled, so nothing can be done.
If rst.EOF Then
    MsgBox ("Can't confirm Software version - Support required")
ElseIf rst("Version") <> SoftwareVersion Then
    MsgBox ("This is not the correct software version, please copy the latest live version")
End If
SQLTime = rst("SQLDate")
WindowsTime = Now
rst.Close

TimeOffset = DateDiff("h", SQLTime, WindowsTime)

' Check that there aren't any inbound folders without backslash on end
strSQL = "select count(*) as Count from dbo.ct_jobs where right(inboundfolder,1) <>'\'"
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

If rst("Count") > 0 Then
    MsgBox ("Entries found with Invalid source folders, Please correct before continuing")
End If
rst.Close

Call ClearFolders

End Sub
Public Function SetDBConnection()
' DLC 151 - Identify which mode we are running in and check views are all matching

Dim dbLocal As dao.Database
Dim rst As dao.Recordset
Dim SQL As String
Dim result As Boolean
Dim td As TableDef
Dim tds As TableDefs
Dim myConnection As String
Dim ActiveServer As String
Dim NewConnection As String
Dim FullConnection As String

Set dbLocal = CurrentDb

' get active config entry
SQL = "Select * from Config where enabled"
Set rst = dbLocal.OpenRecordset(SQL)
rst.MoveLast

' Ensure only one active connection selected
If rst.RecordCount <> 1 Then
    MsgBox ("Invalid SQL Configuration - Please contact Technical Operations")
    DoCmd.Quit
End If

ActiveServer = LCase(rst("ConnectionString"))

' setup correct connection string
FullConnection = Replace(ConnectionTemplate, "<ACTIVE_SERVER>", ActiveServer)

 'check all views are configured for the active server
For Each td In dbLocal.TableDefs
    If Len(Trim(td.SourceTableName)) > 0 Then
        myConnection = LCase(td.Connect)
        ' Debug.Print myConnection
        If InStr(myConnection, ActiveServer) = 0 Then
            MsgBox ("Found Incorrect View Connection on startup, " & vbCrLf & myConnection)
            DoCmd.Quit
        End If
    End If
Next

' set Background colour and form Caption to highlight mode

lblModeType.Caption = rst("Mode") + " Operation"

If LCase(rst("Mode")) <> "live" Then
    MsgBox ("Console is operating in " & rst("Mode") & " mode "), vbCritical
End If

Select Case UCase(rst("ScreenColour"))
Case "RED"
    lblModeType.BackColor = vbRed
Case "BLUE"
    lblModeType.BackColor = vbBlue
    lblModeType.ForeColor = vbWhite
Case "WHITE"
    lblModeType.BackColor = vbWhite
Case Else
    MsgBox ("Invalid Form Colour:" & rst("ScreenColour"))
    DoCmd.Quit
End Select

rst.Close

SetDBConnection = FullConnection

End Function

Function GetWindowsUserName() As String
    
    Dim lngLen As Long
    Dim strBuffer As String
    
    Const dhcMaxUserName = 255
    
    strBuffer = Space(dhcMaxUserName)
    lngLen = dhcMaxUserName
    If CBool(GetUserName(strBuffer, lngLen)) Then
        GetWindowsUserName = Left$(strBuffer, lngLen - 1)
    Else
        GetWindowsUserName = ""
    End If
End Function

Function CheckFileDetails(lngFileID As Long) As Boolean
' verify that the specified files dates and sizes match up

    Dim F As File
    Dim rst As Recordset
    Dim strSQL As String
    Dim blnResult As Boolean
    Dim strFile As String
    
    Set rst = New Recordset
    strSQL = "select * from dbo.vw_ExistingFiles where fileid = " & LTrim(str(lngFileID))
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

    If rst.EOF Then
        ' file no longer in view (some one else may have processed it
        blnResult = False
    Else
        strFile = rst("Folder") & rst("Filename")
        If Not fso.FileExists(strFile) Then
            ' file no longer available in source location
            blnResult = False
        Else
            ' compare details with those on SQL
            Set F = fso.GetFile(strFile)
            
            If F.Size <> rst("FileSize") Then
                blnResult = False
            ElseIf AdjustDate(F.DateCreated) <> rst("CreatedDate") Then
                blnResult = False
            ElseIf AdjustDate(F.DateLastModified) <> rst("UpdatedDate") Then
                blnResult = False
            Else
                blnResult = True
            End If
                    
        End If
    End If
    CheckFileDetails = blnResult

End Function

Function CheckFileExists(lngFileID As Long, JobNumber As String) As String

    Dim rst As Recordset
    Dim strSQL As String
    Dim strFile As String
    Dim HeaderInFirstRow As Boolean

        
    Set rst = New Recordset
    strSQL = "select * from dbo.vw_ExistingFiles where fileid = " & LTrim(str(lngFileID))
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

    If rst.EOF Then
        MsgBox ("file no longer in view (some one else may have processed it)")
        CheckFileExists = "not in view"
        rst.Close
    Else
        strFile = rst("Folder") & rst("Filename")
        rst.Close
        
        'CTC 116 - variable is being used in PS script CalltraceFileExists_ToRelease.ps1. If No header in first row then just checking if a file is empty
        
        HeaderInFirstRow = GetHeaderInFirstRow(JobNumber)
            
        'If a source file is on the local drive
        If InStr(1, strFile, "\\cig.local\Data\Marketing Solutions Departments\Production\", vbTextCompare) > 0 Then
            CheckFileExists = CheckFileExists_Local(strFile, HeaderInFirstRow)
        Else
            CheckFileExists = CheckFileExists_EFT(lngFileID, JobNumber, HeaderInFirstRow, strFile)
        End If
    End If

End Function
Function CheckFileExists_EFT(lngFileID As Long, JobNumber As String, ByVal HeaderInFirstRow As Boolean, strFile As String) As String

    Dim fileExistsTriggerFullPath As String
    Dim foundFolder As String
    Dim fileFoundPath As String
    Dim foundNotEmpty As String
    Dim fileFoundNotEmptyPath As String
    Dim foundEmpty As String
    Dim fileFoundEmptyPath As String
    Dim fileNotFoundPath As String
    Dim notFoundFolder As String
    Dim fileExistsTriggerToProcessFolder As String
    Dim attemptCount As Integer
    Dim maxAttempts As Integer
    
    Dim Fileout As TextStream
            
    'Setup trigger folder paths and paths to the triggers
    fileExistsTriggerToProcessFolder = FileExistsTriggerFolder & "ToProcess\"
    fileExistsTriggerFullPath = fileExistsTriggerToProcessFolder & lngFileID & ".trg"
    
    foundFolder = FileExistsTriggerFolder & "Found\"
    foundNotEmpty = foundFolder & "NotEmpty\"
    foundEmpty = foundFolder & "Empty\"
    notFoundFolder = FileExistsTriggerFolder & "NotFound\"
    
    fileFoundNotEmptyPath = foundNotEmpty & lngFileID & ".trg"
    fileFoundEmptyPath = foundEmpty & lngFileID & ".trg"
    fileNotFoundPath = notFoundFolder & lngFileID & ".trg"
    'fileDonePath
    
    
    'Before checking the trigger file, make sure to delete it if it was created before

    Call DeleteFile(fileFoundNotEmptyPath)
    Call DeleteFile(fileFoundEmptyPath)
    Call DeleteFile(fileNotFoundPath)

    
    'EFT 769 - Adding additional check if a file is already exist.

    Call DeleteFile(fileExistsTriggerFullPath)

    'Create a trigger file called by fileID
    
    Set Fileout = fso.CreateTextFile(fileExistsTriggerFullPath, True, True)
    
    Dim strHeaderInFirstRow As String
    strHeaderInFirstRow = CStr(HeaderInFirstRow)
    
    'Set trigger content to full file path (first row)
    Fileout.Write strFile
    Fileout.Write vbCrLf
    'Adding new line JobNumber (second row)
    Fileout.Write JobNumber
    Fileout.Write vbCrLf
    'Adding new line HeaderInFirstRow (third row)
    Fileout.Write HeaderInFirstRow
    
    Fileout.Close
    Set Fileout = Nothing
    
    'Loop until trigger file appears in one of the three folders
    'CTC 127
    attemptCount = 0
    maxAttempts = 3
    
    Do While attemptCount < maxAttempts
       If (fso.FileExists(fileFoundNotEmptyPath) Or fso.FileExists(fileFoundEmptyPath) Or fso.FileExists(fileNotFoundPath)) Then
           ' File found, break out of the loop
           Exit Do
       End If
       attemptCount = attemptCount + 1
       Sleep (3)
    Loop
    
    If attemptCount = maxAttempts Then
        MsgBox "Trigger file not found after multiple attempts."
        CheckFileExists_EFT = "trigger notfound"
        Exit Function
    End If
    
    'Check if trigger file was moved to notfound,FoundNotEmpty and FoundEmpty subfolders
    If fso.FileExists(fileNotFoundPath) Then
        CheckFileExists_EFT = "not found"
        Call DeleteFile(fileNotFoundPath)
    ElseIf fso.FileExists(fileFoundNotEmptyPath) Then
        CheckFileExists_EFT = "OK"
        Call DeleteFile(fileFoundNotEmptyPath)
    ElseIf fso.FileExists(fileFoundEmptyPath) Then
        CheckFileExists_EFT = "Is empty"
        Call DeleteFile(fileFoundEmptyPath)
    End If


End Function
Function CheckFileExists_Local(myFile As String, ByVal HeaderInFirstRow As Boolean) As String

Dim fso As Object
Dim mf As Object

Set fso = CreateObject("Scripting.FileSystemObject")

' Nothing to do unless the file exists
If Not fso.FileExists(myFile) Then
    CheckFileExists_Local = "not found"
Else
    Set mf = fso.GetFile(myFile)
    
    If mf.Size > 0 Then
        If HeaderInFirstRow Then
            ' If not empty, then need to check how many lines are in it
            If ContainsMultipleLines(myFile) Then
                CheckFileExists_Local = "OK"
            Else
                ' File contains only header
                CheckFileExists_Local = "Is empty"
            End If
        Else
            CheckFileExists_Local = "OK"
        End If
    Else
        CheckFileExists_Local = "Is empty"  ' File is empty
    End If
End If
End Function
'CTC 126
Function GetHeaderInFirstRow(JobNumber As String) As Boolean

Dim strSQL As String
Dim rst As Recordset

'Default value is False
GetHeaderInFirstRow = False

strSQL = "SELECT HeadersInFirstRow FROM neptunefileimporter.[fileimporter].[Jobs] "
strSQL = strSQL & "WHERE JobId IN (SELECT Max(JobId) FROM neptunefileimporter.[fileimporter].[Jobs] WHERE DestinationTable = '" & JobNumber & "')"

On Error Resume Next
Set rst = New Recordset
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
On Error GoTo 0

If Not rst.EOF Then
    GetHeaderInFirstRow = rst("HeadersInFirstRow")
Else
    MsgBox "Error retrieving HeadersInFirstRow value from neptunefileimporter.[fileimporter].[Jobs]"
End If

rst.Close

End Function
Function ContainsMultipleLines(FileName As String) As Boolean

Dim fso As Object
Dim mf As Object
Dim LineCount As Long

Set fso = CreateObject("Scripting.FileSystemObject")

ContainsMultipleLines = False

' Attempt to open the file
On Error Resume Next
Set mf = fso.OpenTextFile(FileName, 1)
On Error GoTo 0

If Not mf Is Nothing Then
    LineCount = 0
    
    ' Count the lines in the file
    Do While Not mf.AtEndOfStream And LineCount < 2
        mf.ReadLine
        LineCount = LineCount + 1
    Loop
    
    mf.Close
    
    If LineCount > 1 Then
        ContainsMultipleLines = True
    Else
        ContainsMultipleLines = False
    End If
    
End If

End Function
'CTC 121
Function DeleteFile(filePath As String)
    Dim fso As Object
    Dim attemptCount As Integer
    Dim maxAttempts As Integer
    Dim success As Boolean
    
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    ' Check if the file exists before attempting to delete
    If Not fso.FileExists(filePath) Then
        Exit Function
    End If
    
    attemptCount = 0
    maxAttempts = 6
    
    Do While attemptCount < maxAttempts
        ' Attempt to delete the file
        On Error Resume Next
        fso.DeleteFile filePath
        On Error GoTo 0
        
        ' Check if the file still exists after deletion attempt
        If Not fso.FileExists(filePath) Then
            success = True
            Exit Do
        End If
        
        ' Wait for 10 seconds before the next deletion attempt
        Sleep (10)
        
        attemptCount = attemptCount + 1
    Loop
    
    ' Message if the file could not be deleted after multiple attempts
    If Not success Then
        MsgBox "Trigger file '" & filePath & "' could not be deleted after multiple attempts."
    End If
      
End Function
Function AdjustDate(dtDateIn As Date) As Date
' remove the seconds from a date and time value to match that stored in SQL and adjust for different time zones

Dim strDate As String

dtDateIn = DateAdd("h", -TimeOffset, dtDateIn)

strDate = Format(dtDateIn, "dd/mm/yyyy HH:MM")

AdjustDate = strDate

End Function


Function strFileFromFolder(strFullFile As String) As String

Dim strOut As String
Dim intP As Integer

strOut = Trim(strFullFile)

' read through until no more slashes
Do
    intP = InStr(strOut, "\")
    If intP = Len(strOut) Then
        ' last character so no filename
        strOut = ""
        intP = 0
    ElseIf intP > 0 Then
        strOut = Mid(strOut, intP + 1)
    End If
Loop While intP > 0

strFileFromFolder = strOut

End Function

Public Sub ShellAndWait(ByVal PathName As String, Optional WindowState)
    
    Dim hProg As Variant
    Dim hProcess As Long, ExitCode As Long
    Dim fso As FileSystemObject
    
    Set fso = CreateObject("scripting.FileSystemObject")
    
    hProg = Shell(PathName, WindowState)
    
    'hProg is a "process ID under Win32. To get the process handle:
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, hProg)
    Do
        'populate Exitcode variable
        GetExitCodeProcess hProcess, ExitCode
        DoEvents
    Loop While ExitCode = STILL_ACTIVE

End Sub
'CTC 091 Copy Job number to clipboard on double click
Private Sub lblJDJobNo_DblClick(Cancel As Integer)
    Set ClipBoard = New DataObject
    ClipBoard.SetText lblJDJobNo.Caption
    ClipBoard.PutInClipboard
    MsgBox ("Job Number " & lblJDJobNo.Caption & " has been copied to the clipboard")
End Sub

Private Sub lstActiveJobs_DblClick(Cancel As Integer)

Dim intRunID As Long

'have we got an entry selected
If Not IsNull(lstActiveJobs.Value) Then
    
    intRunID = lstActiveJobs.Value
    Call Progressjob(intRunID)

End If

End Sub


Private Sub lstFileView_DblClick(Cancel As Integer)

Call LinkFile

End Sub

Private Sub lstJobStatus_Click()

    lblEditRunStatus.Caption = lstJobStatus.Value
    cmdEditRunCancel.SetFocus
    lstJobStatus.Visible = False

End Sub




Private Sub pgFileList_Click()

    ' refresh view
    lstFileView.Requery

End Sub

Private Sub pgJobList_Click()

    cmdActiveJobsRefresh.Caption = "Refreshing..."
    cmdActiveJobsRefresh.Enabled = False
    Call CheckNeptuneStatus
    lstActiveJobs.Requery
    cmdActiveJobsRefresh.Caption = "Refresh"
    cmdActiveJobsRefresh.Enabled = True

End Sub

Sub SetActions(strStatus As String)
' set the command buttons on the job details page depending on what the current job status is.

lblJDRunStatus.Caption = strStatus

' defaults
'cmdJDBack.SetFocus

'cmdSetupJob.Enabled = False
cmdLaunch.Enabled = False
cmdProcessedJob.Enabled = False
cmdCancelJob.Enabled = False
cmdDeliverJob.Enabled = False
cmdFailJob.Enabled = False
cmdRestartJob.Enabled = False
cmdLaunchFailed.Enabled = False
cmdQCJob.Enabled = False
cmd_JD_CheckError.Enabled = False

Select Case LCase(Trim(strStatus))
Case "logged"
    cmdCancelJob.Enabled = True
    'cmdSetupJob.Enabled = True
    'cmdSetupJob.SetFocus
Case "pre-processing"
    cmdCancelJob.Enabled = True
    cmdLaunch.Enabled = True
    cmdFailJob.Enabled = True ' #CTC028
Case "running"
    cmdLaunchFailed.Enabled = True
    cmdFailJob.Enabled = True
    cmdProcessedJob.Enabled = True
    cmd_JD_CheckError.Enabled = True
    If chkLaunchJob.Value = False Then
        cmdProcessedJob.SetFocus
    End If
Case "neptune complete"
    cmdCancelJob.Enabled = True
    cmdLaunchFailed.Enabled = True
    cmdFailJob.Enabled = True
    cmdProcessedJob.Enabled = True
    cmdProcessedJob.SetFocus
Case "check job"
    cmdCancelJob.Enabled = True
    cmdLaunchFailed.Enabled = True
    cmdFailJob.Enabled = True
    cmdProcessedJob.Enabled = True
    cmdRestartJob.Enabled = True
    cmd_JD_CheckError.Enabled = True
    cmdProcessedJob.SetFocus
Case "launch failed"
    cmdCancelJob.Enabled = True
    cmdLaunch.Enabled = True
    cmdLaunch.SetFocus
Case "failed", "data issue"
    cmdCancelJob.Enabled = True
    cmdRestartJob.Enabled = True
    cmd_JD_CheckError.Enabled = True
    cmdRestartJob.SetFocus
Case "in qc"
    cmdCancelJob.Enabled = True
    cmdFailJob.Enabled = True
    cmdQCJob.Enabled = True
    cmdQCJob.SetFocus
Case "verified"
    cmdCancelJob.Enabled = True
    cmdDeliverJob.Enabled = True
    cmdDeliverJob.SetFocus
Case "complete", "cancelled"
    ' no actions available
Case Else
    MsgBox ("Unknown Status Found " & Trim(strStatus))
End Select

End Sub
Sub UpdateRunStatus(strRunID As String, strStatus As String, intError As Integer, strTTP As String)

Dim strSQL As String

' update the run status for the given job and refresh screen
strSQL = "Update dbo.CT_JobRun Set RunStatus = '" & strStatus & "' where CT_RunID = " & strRunID
db.Execute (strSQL)

' add an entry to the run status audit log
If LCase(strStatus) = "failed" Then
    strSQL = "insert into dbo.CT_RunStatusLog (CT_RunID, CT_Status, UserName, UpdateDate, ErrorType, TTP) "
    strSQL = strSQL & "select " & strRunID & ", '" & strStatus & "', '" & strUserName & "', getdate(), ErrorType, '" & strTTP & "' "
    strSQL = strSQL & "from dbo.CT_ErrorType where CT_ErrorID = " & Trim(intError)
Else
    strSQL = "insert into dbo.CT_RunStatusLog (CT_RunID, CT_Status, UserName, UpdateDate) values (" & strRunID & ", '" & strStatus & "', '" & strUserName & "', getdate()) "
End If

db.Execute (strSQL)

' if completed update the job run with completion date
If LCase(strStatus) = "complete" Then
    strSQL = "Update dbo.CT_JobRun Set CompletedDate = getdate() where ct_runID = " & strRunID
    db.Execute (strSQL)
End If

End Sub

Sub Sleep(intSeconds As Integer)

Dim intNow As Double
Dim intThen As Double
Dim intMidnight As Double

' timer gives number of seconds since midnight
intNow = Timer
intThen = intNow + intSeconds
intMidnight = 60 * 60
intMidnight = intMidnight * 24

' if our sleep crosses midnight?
If intThen > intMidnight Then
    ' wait until midnight first
    While Timer <> 0
    Wend
    intThen = intThen = intMidnight
End If

' now wait until we get there
While Timer < intThen
Wend

End Sub

Private Sub pgRejected_Click()

    lstRejected.Requery

End Sub

Private Sub pgReports_Click()

    Call CheckNeptuneStatus

    lstReport.Requery

End Sub


Private Sub txtTTP_Change()
    lblTTP.Caption = Trim(txtTTP.Text)
End Sub

Sub clearttp()

lblTTP.Caption = ""
txtTTP.SetFocus
txtTTP.Text = ""
pgLogError.SetFocus

End Sub
Function strAssign(varIn As Variant) As String

If IsNull(varIn) Then
    strAssign = ""
Else
    strAssign = varIn
End If

End Function

Function strRenameFile(strTemplate As String, strJobNo As String, strRunNo As String, ByVal strOriginalFile As String) As String

Dim strNewName As String
Dim intP As Integer
Dim LastChar As Integer

If strTemplate <> "" Then

    If LCase(Right(strOriginalFile, 4)) = ".pgp" Then
        strOriginalFile = Left(strOriginalFile, Len(strOriginalFile) - 4)
    End If

    ' remove extension from the original name
    intP = Len(strOriginalFile) + 1
    For LastChar = Len(strOriginalFile) To 1 Step -1
        If Mid(strOriginalFile, LastChar, 1) = "." Then
            intP = LastChar
            Exit For
        End If
    Next LastChar
    strOriginalFile = Left(strOriginalFile, intP - 1)
    
    strNewName = strTemplate
    
    ' replace data elements retaining the case
    intP = InStr(LCase(strNewName), "<jobno>")
    If intP > 0 Then
        strNewName = Left(strNewName, intP - 1) & UCase(Trim(strJobNo)) & Mid(strNewName, intP + Len("<jobno>"))
    End If
    
    intP = InStr(LCase(strNewName), "<runno>")
    If intP > 0 Then
        strNewName = Left(strNewName, intP - 1) & UCase(Trim(strRunNo)) & Mid(strNewName, intP + Len("<runno>"))
    End If
    
    intP = InStr(LCase(strNewName), "<inputfile>")
    If intP > 0 Then
        strNewName = Left(strNewName, intP - 1) & Trim(strOriginalFile) & Mid(strNewName, intP + Len("<inputfile>"))
    End If
   
Else
    strNewName = ""
End If

strRenameFile = strNewName

End Function
Function ZipfolderWrapper(FolderToZip As String, TargetZipName As String) As String
'CTC 104 - loop the ZipFolder function until result = retry and up to 3 times
Dim counter As Integer
Dim result As String

counter = 0

Do
    result = Zipfolder(FolderToZip, TargetZipName)
    counter = counter + 1
    If result = "Retry" Then
        Write_DebugLog ("ZipFolderWrapper - Retrying")
        Sleep (2)
    End If
Loop While counter < 3 And result = "Retry"

ZipfolderWrapper = result

Write_DebugLog ZipfolderWrapper & " ZipfolderWrapper - Result"

End Function
Function CountFilesInFolder(FolderToZip As String) As Variant
'CTC 104 - To count file in a location
Dim Path As String
Dim FileName As String
Dim Count As Integer

Count = 0

Path = FolderToZip & "*.*"
FileName = Dir(Path)

Do While FileName <> ""
    Count = Count + 1
    FileName = Dir()
Loop

CountFilesInFolder = Count
    
End Function
Function Zipfolder(FolderToZip As String, TargetZipName As String) As String

On Local Error GoTo ZipFolder_error

Dim strExec As String
Dim ZipResult As String
Dim Qt As String
Qt = Chr(34)


'Check if this is the path where WinZip unzip command line program is installed.
If Not fso.FileExists(PathZipProgram) Then
    MsgBox ("Unable to detect compression tools (7Zip or WinZip) - Zipping Unavailable")
    Write_DebugLog ("Unable to detect compression tools")
    Exit Function
End If
'Counting files in Zip Folder. Cannot be > 1
If CountFilesInFolder(FolderToZip) = 0 Then
    MsgBox "No files in a zipping folder"
    ZipResult = "Empty Folder"
    Write_DebugLog ("Empty Folder")
    Exit Function
End If


' TOT 334 - use variables to allow multiple Zip versions
strExec = Qt & PathZipProgram & Qt & " " & ZipCompress & " " & Qt & FolderToZip & TargetZipName & Qt & " " & Qt & FolderToZip & "*.*" & Qt

ShellAndWait strExec, vbHide

'CTC 104 - If after zipping there is another file in a folder then delete zipped file.

If fso.FileExists(FolderToZip & TargetZipName) Then
    'ZipFile = Dir(FolderToZip & "*.*")
    If CountFilesInFolder(FolderToZip) > 1 Then  'Dir <> "" Then
        Write_DebugLog ("After zipping more than 1 file, deleting zip file")
        Kill (FolderToZip & TargetZipName)
        ZipResult = "Retry"
    Else
        ZipResult = "OK"
        Write_DebugLog ("Zip Result- OK")
    End If
End If

Zipfolder = ZipResult

Exit Function

ZipFolder_error:
    Write_DebugLog "Function Zipfolder Terminal failure"
    Zipfolder = "Terminal Failure"

End Function

Function ZipList(ZipName As String, OutputFolder As String, OutputFilename As String) As Boolean

On Local Error GoTo ZipList_error

Dim strExec As String
Dim ZipListResult As Boolean
Dim BatFile As Object
Dim Qt As String
Qt = Chr(34)

ZipListResult = False

'Check if this is the path where WinZip unzip command line program is installed.
If Not fso.FileExists(PathZipProgram) Then
    MsgBox ("Unable to detect compression tools (7Zip or WinZip) - Zipping Unavailable")
    Exit Function
End If

' TOT 334 - use variables to allow multiple Zip versions
strExec = Qt & PathZipProgram & Qt & " " & ZipListFlag & " " & Qt & ZipName & Qt & " >" & Qt & OutputFolder & OutputFilename & Qt

Set BatFile = fso.CreateTextFile(OutputFolder & "ListZip.bat")
BatFile.WriteLine (strExec)
BatFile.Close

ShellAndWait OutputFolder & "ListZip.bat", vbHide

If fso.FileExists(OutputFolder & OutputFilename) Then
    ZipListResult = True
End If

ZipList = ZipListResult

Exit Function

ZipList_error:
    ZipList = False

End Function

Function CreateSentData(strAuditLog As String) As Boolean

Dim strOutputFolder As String
Dim strSentFolder As String
Dim strOutputFile As String
Dim strReconFile As String
Dim strDuplicateFile As String
Dim strReportFile As String

' CTC#043#046
Dim strBadInputDataDNAFile As String
Dim strBadOccupierRecordsFile As String

Dim strZipFile As String
Dim strReName As String
Dim strOutputNewName As String

' CTC#043#046
Dim strReNameBadInputDataDNA As String
Dim strReNameBadOccupierRecords As String
Dim blnBadInputDataDNARequired As Boolean
Dim blnBadOccupierRecordsRequired As Boolean

Dim blnCopyForInTouch As Boolean ' 26/09/2018 CRD025 InTouch Tactical Solution

Dim strAttachFolder As String
Dim strEmptyFolder As String
Dim strErrorFile As String
Dim strErrorReport As String
Dim strDuplicatesReport As String
Dim intP As Integer
Dim blnResult As Boolean

' CTC#043#046
Dim strSQL As String
Dim strSQLCT As String
Dim rst As Recordset
Dim rstCT As Recordset
Set rst = New Recordset
Set rstCT = New Recordset
Dim FileMissing As Boolean
Dim FileEmpty As Boolean

' CTC 104
Dim ZipResult As String

NoCTOutput = False
blnBadInputDataDNARequired = False
blnBadOccupierRecordsRequired = False

' CTC#043#046
strSQLCT = "SELECT * FROM DataBureauDataLoadAudit.dbo.vw_CT_CallTraceVersions WHERE JobNo = '" & Trim(lblJDJobNo.Caption) & "'"
rstCT.Open strSQLCT, db, adOpenForwardOnly, adLockReadOnly

' CTC# 061 - No longer a static template name, so flags have been added to determine if these files are required
If Trim(strAssign(rstCT("BadOccupierRecords"))) = "Y" Then
    blnBadOccupierRecordsRequired = True
End If
If Trim(strAssign(rstCT("BadInputDataDNA"))) = "Y" Then
    blnBadInputDataDNARequired = True
End If
rstCT.Close

' CTC#043#046
strSQLCT = "SELECT * FROM DataBureauDataLoadAudit.dbo.CT_Jobs WHERE Job_Number = '" & Trim(lblJDJobNo.Caption) & "'"
rstCT.Open strSQLCT, db, adOpenForwardOnly, adLockReadOnly
If (rstCT("CopyForInTouch")) Then ' 26/09/2018 CRD025 InTouch Tactical Solution
    blnCopyForInTouch = True
End If
rstCT.Close

strAuditLog = "Preparing " & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & " for despatch " & crlf

strSQL = "select * from dbo.vw_CT_OutputDetails where Job_Number = '" & Trim(lblJDJobNo.Caption) & "'"
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

' ClientName, Job_Number, OutboundNamingConvention, ReconNamingConvention, Outputtype, ZipFileNamingConvention, OutputFileFormat, ReportFormat, JobNotes
strOutputFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Output\"
strSentFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Sent\"
strAttachFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Attachments\"
strEmptyFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\NotSent\"

If Not fso.FolderExists(strAttachFolder) Then
    fso.CreateFolder (strAttachFolder)
End If
If Not fso.FolderExists(strSentFolder) Then
    fso.CreateFolder (strSentFolder)
End If
If Not fso.FolderExists(strEmptyFolder) Then
    fso.CreateFolder (strEmptyFolder)
End If
           
' CTC 098 - DPP files have a different output and recon naming convention
If LCase(Trim(lblJDJobType.Caption)) = "dpp" Then
    strOutputFile = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_DPPOutput" & "." & strAssign(rst("OutputFileFormat"))
    strReconFile = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_DPPRecon" & "." & strAssign(rst("OutputFileFormat"))
Else
    strOutputFile = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_CTOutput" & "." & strAssign(rst("OutputFileFormat"))
    strReconFile = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_CTRecon" & "." & strAssign(rst("OutputFileFormat"))
End If

strDuplicateFile = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_Duplicates" & ".csv"
strReportFile = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_Report" & "." & strAssign(rst("ReportFormat"))
strErrorReport = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_Error_Report" & "." & strAssign(rst("ReportFormat"))
strDuplicatesReport = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_Duplicates_Report" & "." & strAssign(rst("ReportFormat"))
strErrorFile = Trim(lblJDFileName.Caption)

' CTC#043#046
strBadInputDataDNAFile = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_" & Trim(lblJDJobType.Caption) & "Output_BadDataInputDNA" & "." & strAssign(rst("OutputFileFormat"))
strBadOccupierRecordsFile = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_" & Trim(lblJDJobType.Caption) & "Output_BadOccupierRecords" & "." & strAssign(rst("OutputFileFormat"))

intP = InStr(strErrorFile, ".")
If intP Then

    ' replace extension from the original name and replace with .err
    For intP = Len(strErrorFile) To 1 Step -1
        If Mid(strErrorFile, intP, 1) = "." Then
            strErrorFile = Left(strErrorFile, intP - 1) & ".err"
            Exit For
        End If
    Next intP
   
Else
    strErrorFile = strErrorFile & ".err"
End If

' if this is run 0 then 0 doesn't appear in the filenames
If Trim(lblJDRunNo.Caption) = "0" Then
    strOutputFile = Replace(strOutputFile, "_0", "")
    strReconFile = Replace(strReconFile, "_0", "")
    strDuplicateFile = Replace(strDuplicateFile, "_0", "")
    strReportFile = Replace(strReportFile, "_0", "")
    strDuplicatesReport = Replace(strDuplicatesReport, "_0", "")
    strErrorReport = Replace(strErrorReport, "_0", "")
    
    ' CTC#043#046
    strBadInputDataDNAFile = Replace(strBadInputDataDNAFile, "_0", "")
    strBadOccupierRecordsFile = Replace(strBadOccupierRecordsFile, "_0", "")
    
End If

strZipFile = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_SNT.zip"

' CTC061 - All Empty files removed
' CSV files which are empty of data still have a header, so identify these and move to a backup location
Call MoveIfEmpty(strOutputFolder & strOutputFile, strEmptyFolder)
Call MoveIfEmpty(strOutputFolder & strReconFile, strEmptyFolder)
Call MoveIfEmpty(strOutputFolder & strDuplicateFile, strEmptyFolder)
Call MoveIfEmpty(strOutputFolder & strErrorFile, strEmptyFolder)

' New mechanism, which checks everything first before actually doing anything.
' if no output file, get operator to confirm
If Not fso.FileExists(strOutputFolder & strOutputFile) Then
    If MsgBox("No Output file found, Continue?", vbYesNo) = vbYes Then
        blnResult = True
        NoCTOutput = True
    Else
        blnResult = False
    End If
Else
    blnResult = True
End If

If blnResult Then
    If Not fso.FileExists(strOutputFolder & strReportFile) Then
        MsgBox ("Report file not found")
        blnResult = False
    ElseIf fso.FileExists(strOutputFolder & strErrorFile) And Not fso.FileExists(strOutputFolder & strErrorReport) Then
        MsgBox ("There is an Error File but no Error Report file, please download before delivery")
        blnResult = False
    ElseIf fso.FileExists(strOutputFolder & strDuplicateFile) And Not fso.FileExists(strOutputFolder & strDuplicatesReport) Then
        MsgBox ("There is a Duplicate File but no Duplicate Report file, please download before delivery")
        blnResult = False
    End If

    ' CTC061 - Check status of 'Bad files'
    FileMissing = Not fso.FileExists(strOutputFolder & strBadInputDataDNAFile)
    FileEmpty = EmptyFile(strOutputFolder & strBadInputDataDNAFile)

    If blnBadInputDataDNARequired Then
        If FileMissing Then
            MsgBox ("The BadInputDataDNA file is expected but missing, this file needs to be in the output folder before the job can be delivered")
            blnResult = False
        ElseIf FileEmpty Then
            Call MoveIfEmpty(strOutputFolder & strBadInputDataDNAFile, strEmptyFolder)
        End If
    Else
        If Not FileMissing Then
            If FileEmpty Then
                Call MoveIfEmpty(strOutputFolder & strBadInputDataDNAFile, strEmptyFolder)
            Else
                MsgBox ("The BadInputDataDNA file is NOT expected but exists and is not empty, this issue needs urgent escalation before the job can be delivered")
                blnResult = False
            End If
        End If
    End If
    
    FileMissing = Not fso.FileExists(strOutputFolder & strBadOccupierRecordsFile)
    FileEmpty = EmptyFile(strOutputFolder & strBadOccupierRecordsFile)
    
    If blnBadOccupierRecordsRequired Then
        If FileMissing Then
            MsgBox ("The BadInputDataDNA file is expected but missing, this file needs to be in the output folder before the job can be delivered")
            blnResult = False
        ElseIf FileEmpty Then
            Call MoveIfEmpty(strOutputFolder & strBadOccupierRecordsFile, strEmptyFolder)
        End If
    Else
        If Not FileMissing Then
            If FileEmpty Then
                Call MoveIfEmpty(strOutputFolder & strBadOccupierRecordsFile, strEmptyFolder)
            Else
                MsgBox ("The BadInputDataDNA file is NOT expected but exists and is not empty, this issue needs urgent escalation before the job can be delivered")
                blnResult = False
            End If
        End If
    End If
End If

If blnResult Then
    ' CTC061 All standard files output where they exist
    If fso.FileExists(strOutputFolder & strOutputFile) Then

        fso.CopyFile strOutputFolder & strOutputFile, strSentFolder

        strAuditLog = strAuditLog & "Output file copied to Sent folder" & crlf
           
        If blnCopyForInTouch Then ' 26/09/2018 CRD025 InTouch Tactical Solution
            Dim strInTouchPath As String
            strInTouchPath = InTouchFolder & Trim(lblJDJobNo.Caption) & "\"
            
            If Not fso.FolderExists(strInTouchPath) Then
                fso.CreateFolder (strInTouchPath)
                strAuditLog = strAuditLog & "Folder created for InTouch input: " & strInTouchPath & crlf
            End If
            
            fso.CopyFile strOutputFolder & strOutputFile, strInTouchPath
            strAuditLog = strAuditLog & "Output file copied for InTouch processing" & crlf
        End If

        ' Rename if neccessary
        strOutputNewName = strRenameFile(strAssign(rst("OutboundNamingConvention")), Trim(lblJDJobNo.Caption), Trim(lblJDRunNo.Caption), Trim(lblJDFileName.Caption))

        If strOutputNewName <> "" Then
            fso.MoveFile strSentFolder & strOutputFile, strSentFolder & strOutputNewName
            strAuditLog = strAuditLog & strOutputFile & " renamed to " & strOutputNewName & crlf
        End If
    Else
        strAuditLog = strAuditLog & "Output file not found" & crlf
    End If

    ' Next the recon file
    If fso.FileExists(strOutputFolder & strReconFile) Then
    
        fso.CopyFile strOutputFolder & strReconFile, strSentFolder
        strAuditLog = strAuditLog & "Recon file copied to Sent folder" & crlf
        
        ' Rename if neccessary
        strReName = strRenameFile(strAssign(rst("ReconNamingConvention")), Trim(lblJDJobNo.Caption), Trim(lblJDRunNo.Caption), Trim(lblJDFileName.Caption))
    
        If strReName <> "" Then
            fso.MoveFile strSentFolder & strReconFile, strSentFolder & strReName
            strAuditLog = strAuditLog & strReconFile & " renamed to " & strReName & crlf
            strReconFile = strReName
        End If
    Else
        strAuditLog = strAuditLog & "Recon file not found" & crlf
    End If
    
    ' Next the Duplicate file
    If fso.FileExists(strOutputFolder & strDuplicateFile) Then
    
        fso.CopyFile strOutputFolder & strDuplicateFile, strSentFolder
        strAuditLog = strAuditLog & "Duplicate file copied to Sent folder" & crlf
            
    Else
        strAuditLog = strAuditLog & "Duplicate file not found" & crlf
    End If
       
    ' CTC#043#046 - BadInputDataDNAFile
    ' CTC 061 - Simplified the process for these files
    If fso.FileExists(strOutputFolder & strBadInputDataDNAFile) Then

        fso.CopyFile strOutputFolder & strBadInputDataDNAFile, strSentFolder

        strAuditLog = strAuditLog & "BadInputDataDNA file copied to Sent folder" & crlf
           
        ' Rename if neccessary
        strReNameBadInputDataDNA = strRenameFile(strAssign(rst("OutboundNamingConvention")), Trim(lblJDJobNo.Caption), Trim(lblJDRunNo.Caption), Trim(lblJDFileName.Caption))
        strReNameBadInputDataDNA = Replace(strReNameBadInputDataDNA, ".csv", "_BadDataInputDNA.csv")
        strReNameBadInputDataDNA = Replace(strReNameBadInputDataDNA, ".txt", "_BadDataInputDNA.txt")

        If strReNameBadInputDataDNA <> "" Then
            fso.MoveFile strSentFolder & strBadInputDataDNAFile, strSentFolder & strReNameBadInputDataDNA
            strAuditLog = strAuditLog & strBadInputDataDNAFile & " renamed to " & strReNameBadInputDataDNA & crlf
        End If
    Else
        strAuditLog = strAuditLog & "BadInputDataDNA file not found" & crlf
    End If


    ' CTC#043#046 - BadOccupierRecordsFile
    If fso.FileExists(strOutputFolder & strBadOccupierRecordsFile) Then

        fso.CopyFile strOutputFolder & strBadOccupierRecordsFile, strSentFolder

        strAuditLog = strAuditLog & "BadOccupierRecords file copied to Sent folder" & crlf
           
        ' Rename if neccessary
        strReNameBadOccupierRecords = strRenameFile(strAssign(rst("OutboundNamingConvention")), Trim(lblJDJobNo.Caption), Trim(lblJDRunNo.Caption), Trim(lblJDFileName.Caption))
        strReNameBadOccupierRecords = Replace(strReNameBadOccupierRecords, ".csv", "_BadOccupierRecords.csv")
        strReNameBadOccupierRecords = Replace(strReNameBadOccupierRecords, ".txt", "_BadOccupierRecords.txt")

        If strReNameBadOccupierRecords <> "" Then
            fso.MoveFile strSentFolder & strBadOccupierRecordsFile, strSentFolder & strReNameBadOccupierRecords
            strAuditLog = strAuditLog & strBadOccupierRecordsFile & " renamed to " & strReNameBadOccupierRecords & crlf
        End If
    Else
        strAuditLog = strAuditLog & "BadOccupierRecords file not found" & crlf
    End If
       
    ' the Error file
    If fso.FileExists(strOutputFolder & strErrorFile) Then

        fso.CopyFile strOutputFolder & strErrorFile, strSentFolder
           
        strAuditLog = strAuditLog & "Error file copied to Sent folder" & crlf

    Else
        strAuditLog = strAuditLog & "Error file not found" & crlf
    End If
    
    ' the report file
    If fso.FileExists(strOutputFolder & strReportFile) Then
    
        fso.CopyFile strOutputFolder & strReportFile, strSentFolder
            
        ' copy for email attachments too
        fso.CopyFile strOutputFolder & strReportFile, strAttachFolder
    
        strAuditLog = strAuditLog & "Report file copied to Sent folder" & crlf
    Else
        strAuditLog = strAuditLog & "Report file not found" & crlf
    End If
    
    ' the error report file
    If fso.FileExists(strOutputFolder & strErrorReport) Then
    
        fso.CopyFile strOutputFolder & strErrorReport, strSentFolder
           
        ' copy for email attachments too
        fso.CopyFile strOutputFolder & strErrorReport, strAttachFolder
    
        strAuditLog = strAuditLog & "error report file copied to Sent folder" & crlf
    Else
        strAuditLog = strAuditLog & "ErrorReport file not found" & crlf
    End If
   
    ' the Duplicates report file
    If fso.FileExists(strOutputFolder & strDuplicatesReport) Then
    
        fso.CopyFile strOutputFolder & strDuplicatesReport, strSentFolder
           
        ' copy for email attachments too
        fso.CopyFile strOutputFolder & strDuplicatesReport, strAttachFolder
    
        strAuditLog = strAuditLog & "Duplicate report file copied to Sent folder" & crlf

    Else
        strAuditLog = strAuditLog & "Duplicate report file not found" & crlf
    End If
    
    ' now zip the folder up if required
    
    If LCase(Trim(rst("Outputtype"))) = "zipped" Then
        
        ' Rename if neccessary
        strReName = strRenameFile(strAssign(rst("ZipFileNamingConvention")), Trim(lblJDJobNo.Caption), Trim(lblJDRunNo.Caption), Trim(lblJDFileName.Caption))
        
        If strReName <> "" Then
            strZipFile = strReName
        End If
        
        ZipResult = ZipfolderWrapper(strSentFolder, strZipFile)
        If ZipResult = "OK" Then
            strAuditLog = strAuditLog & "Sent Folder Zipped" & crlf
            Write_DebugLog ("Zip Final Result - OK")
            ' if output file is also sent unzipped then re-copy this one
            If strAssign(rst("OutputToSFTP")) = "True" Then
                If fso.FileExists(strOutputFolder & strOutputFile) Then
                    fso.CopyFile strOutputFolder & strOutputFile, strSentFolder
                            
                    ' Rename if neccessary
                    If strOutputNewName <> "" Then
                        fso.MoveFile strSentFolder & strOutputFile, strSentFolder & strOutputNewName
                        strAuditLog = strAuditLog & strOutputFile & " renamed to " & strOutputNewName & crlf
                    End If
                End If
            End If
        'CTC 104 - Actions if zipping fails.
        ElseIf ZipResult = "Retry" Then
            Write_DebugLog ("Zip Final Result - Retry")
            strAuditLog = strAuditLog & "Sent Folder NOT Zipped. To many files in a zip folder" & crlf
            MsgBox ("Output Zipping Failed" & vbCrLf & "Following multiple retries," & vbCrLf & "Source files could not be removed from the folder after zipping." & vbCrLf & "Seek support from EFT-CD")
            Exit Function
        ElseIf ZipResult = "Empty Folder" Then
            Write_DebugLog ("Zip Final Result - Empty Folder")
            strAuditLog = strAuditLog & "Sent Folder NOT Zipped. Zip folder is empty" & crlf
            MsgBox ("Output Zipping Failed" & vbCrLf & "Zip folder is empty" & vbCrLf & "Seek support from EFT-CD")
            Exit Function
        ElseIf ZipResult = "Terminal Failure" Then
            Write_DebugLog ("Terminal Failure")
            strAuditLog = strAuditLog & "Sent Folder NOT Zipped, Terminal Failure" & crlf
            MsgBox ("Output Zipping Failed" & vbCrLf & "Terminal issue, raise with EFT-CD team" & vbCrLf & "UKDataOperationsEFTCD@transunion.com ")
            Exit Function
        End If
    Else
        strAuditLog = strAuditLog & "Zip Not Required" & crlf
        Write_DebugLog ("Zip not required")
    End If
    
    strAuditLog = strAuditLog & "Sent information created" & crlf

End If

CreateSentData = blnResult

End Function
' #CTC 093 - Add boolean parameter to return true if internal delivery
Sub CreateDeliveryDocument(ByRef strSentFolder As String, ByRef strDeliveryFolder As String, ByRef InternalDelivery As Boolean)

    Dim strSQL As String
    Dim strSubject As String
    Dim strBody As String
    Dim strAttachFolder As String
    Dim strSuppliedFile As String
    Dim strSuppliedFolder As String
    Dim strSentFile As String
    Dim rst As Recordset
    Dim emailTo As String
    Dim EmailCC As String
    Dim myCount As Integer
    Dim attachements() As String
        
    On Error Resume Next
    
    Set rst = New Recordset
    
    ' CTC 089 - Use a new procedure which has new logic for determining recipients
    strSQL = "exec [dbo].[up_CT_GetAllEmails] '" & Trim(lblJDJobNo.Caption) & "'"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    ' CTC 089 - procedure returns >0 if successful
    If rst("Success") = 0 Then
        MsgBox ("Unable to retrieve email recipient list")
    Else
        While Not rst.EOF
        
            Select Case UCase(Trim(rst("EmailUse")))
            Case UCase("Delivery To")
                emailTo = emailTo & Trim(rst("EmailAddress")) & ";"
            Case UCase("Delivery CC")
                EmailCC = EmailCC & Trim(rst("EmailAddress")) & ";"
            Case Else
                ' ignore
            End Select
            
            rst.MoveNext
        Wend
    End If
    rst.Close
    
           
    strSQL = "select * from dbo.vw_CT_EmailDetails where Job_Number = '" & Trim(lblJDJobNo.Caption) & "' and RunNo = '" & Trim(lblJDRunNo.Caption) & "'"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

    ' CTC 098 - Use new Job Type label to set email subject
    Select Case LCase(lblJDJobType.Caption)
    Case "ct"
        strSubject = strAssign(rst("Job_Number")) & "/" & strAssign(rst("RunNo")) & " " & strAssign(rst("ClientName")) & " - CallTrace Delivery Notification"
    Case "it"
        strSubject = strAssign(rst("Job_Number")) & "/" & strAssign(rst("RunNo")) & " " & strAssign(rst("ClientName")) & " - InTouch Delivery Notification"
    Case "dpp"
        strSubject = strAssign(rst("Job_Number")) & "/" & strAssign(rst("RunNo")) & " " & strAssign(rst("ClientName")) & " - Debt Pre-Purchase Delivery Notification"
    Case Else
        MsgBox ("Unable to determine Job Type")
        Exit Sub
    End Select
    
    ' strSubject = strAssign(rst("Job_Number")) & "/" & strAssign(rst("RunNo")) & " " & strAssign(rst("ClientName")) & " - CallTrace Delivery Notification"
    strSentFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Sent\"
    strAttachFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Attachments\"
    
    ' #CTC016
    ' changed from the following:
    ' strDeliveryFolder = LCase(strAssign(rst("OutboundFolder")))
    strDeliveryFolder = strAssign(rst("OutboundFolder"))
    
    ' #CTC 093 - Replace Data Out with multiple DTP locations for internal outputs
    If LCase(strDeliveryFolder) = "data out" Then
        MsgBox ("This job is configured to deliver outputs to Data Out which is no longer accessible, please correct the output location before attempting to deliver")
        strDeliveryFolder = ""
        Exit Sub
    End If
    
    ' #CTC 093 - new method allows aliases which are found in Config table
    If Left(strDeliveryFolder, 1) = "<" And Right(strDeliveryFolder, 1) = ">" Then
        InternalDelivery = True
        
        strDeliveryFolder = Replace(Replace(strDeliveryFolder, "<", ""), ">", "")
        
        Dim rstConfig As Recordset
        Set rstConfig = New Recordset
        
        strSQL = "select top 1 * from dbo.CT_Config where ConfigItem = '" & strDeliveryFolder & "'"
        rstConfig.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
        If rstConfig.EOF Then
            MsgBox ("Unable to correlate Output Folder " & strDeliveryFolder & ", please correct the output location before attempting to deliver")
            strDeliveryFolder = ""
            Exit Sub
        End If
        
        strDeliveryFolder = strAssign(rstConfig("ConfigValue"))
        rstConfig.Close
    Else
        InternalDelivery = False
    End If
    
    ' #CTC 093 - Allow JobNumber and RunNumber to be used in the output spec
    strDeliveryFolder = Replace(Replace(strDeliveryFolder, "<JobNumber>", Trim(lblJDJobNo.Caption)), "<RunNumber>", Trim(lblJDRunNo.Caption))
        
    ' CTC 098 - Data Out is no longer an option
    If Right(strDeliveryFolder, 1) <> "\" Then
        strDeliveryFolder = strDeliveryFolder & "\"
    End If

    strSuppliedFile = strAssign(rst("SuppliedFile"))
    strSuppliedFolder = strAssign(rst("SuppliedFolder"))
    If Right(strSuppliedFolder, 1) <> "\" Then strSuppliedFolder = strSuppliedFolder + "\"
        
    strBody = "<html>"
    strBody = strBody & "<body style = ""font-family:arial,helvetica,sans-serif;font-size:11pt;"">"
    strBody = strBody & "<p>Hello</p>"
    strBody = strBody & "<p>The data for this job has been output as follows</p>"
    
    If NoCTOutput Then
        strBody = strBody & "<p>** Please note this job has not returned any matches and therefore there is no CTOutput file for this run **</p>"
    End If
    
    strBody = strBody & "<table style = ""font-family:arial,helvetica,sans-serif;font-size:11pt;margin:0px;padding:0px;border-collapse:collapse;"">"
    strBody = strBody & "   <tr>"
    strBody = strBody & "       <th style = ""margin:0px;padding:5px;background-color:#00A6CA;color:#ffffff;text-align:left;"">&nbsp;</th>"
    strBody = strBody & "       <th style = ""margin:0px;padding:5px;background-color:#00A6CA;color:#ffffff;text-align:left;"">File</th>"
    strBody = strBody & "       <th style = ""margin:0px;padding:5px;background-color:#00A6CA;color:#ffffff;text-align:left;"">Date</td>"
    strBody = strBody & "   </tr>"
    strBody = strBody & "   <tr>"
    strBody = strBody & "       <td style = ""font-weight:bold;font-size:11pt;margin:0px;padding:5px;border-bottom-style:solid;border-width:1px;border-color:#999999;"">Input File</td>"
    strBody = strBody & "       <td style = ""font-size:11pt;margin:0px;padding:5px;border-bottom-style:solid;border-width:1px;border-color:#999999;"">" & strSuppliedFolder & strSuppliedFile & "</td>"
    strBody = strBody & "       <td style = ""font-size:11pt;margin:0px;padding:5px;border-bottom-style:solid;border-width:1px;border-color:#999999;"">" & strAssign(rst("SuppliedDate")) & "</td>"
    strBody = strBody & "   </tr>"
    strBody = strBody & "   <tr>"
    strBody = strBody & "       <td style = ""font-weight:bold;font-size:11pt;margin:0px;padding:5px;border-bottom-style:solid;border-width:1px;border-color:#999999;vertical-align:top;"">Output Files</td>"
    strBody = strBody & "       <td style = ""font-size:11pt;margin:0px;padding:5px;border-bottom-style:solid;border-width:1px;border-color:#999999;"">"
                
    strSentFile = Dir(strSentFolder & "*.*")
    While Len(strSentFile) > 0
        strBody = strBody & strDeliveryFolder & strSentFile & "<br />"
        strSentFile = Dir
    Wend
    strBody = strBody & "       </td>"
    strBody = strBody & "       <td style = ""font-size:11pt;margin:0px;padding:5px;border-bottom-style:solid;border-width:1px;border-color:#999999;vertical-align:top;"">" & AdjustDate(Now) & "</td>"
    strBody = strBody & "   </tr>"
    strBody = strBody & "</table>"
        
    'CTC 100 - save attachments into array
    strSentFile = Dir(strAttachFolder & "*.*")
    While Len(strSentFile) > 0
        myCount = myCount + 1
        ReDim Preserve attachements(1 To myCount)
        attachements(myCount) = strAttachFolder & strSentFile
        strSentFile = Dir

        If InStr(LCase(strSentFile), "_Error_Report.") Then
            strBody = strBody & "<p>Error Report Attached</p>"
        ElseIf InStr(LCase(strSentFile), "_Duplicates_Report.") Then
            strBody = strBody & "<p>Error Duplicate Report Attached</p>"
        ElseIf InStr(LCase(strSentFile), "_Report.") Then
            strBody = strBody & "<p>Report Attached</p>"
        End If
        
    Wend
    
    ' #CTR053 - 24/09/2018 - output notification text changed
    strBody = strBody & "<p>Questions, queries, issues and additional requirements or changes in relation to this job should be directed to the Data Bureau team using Test Track Pro by filling in the ""Complaint Tracking"" section.</p>"
    strBody = strBody & "<p>Regards</p>"
    strBody = strBody & "</body>"
    strBody = strBody & "</html>"
    
    ' CTC 100
    If Not sendEmail(emailTo, strSubject, strBody, EmailCC, attachements) Then
        strDeliveryFolder = ""
    End If

    ' #CTC016
    ' this might be unnecessary convertion as it is not being used in the calling procedure for anything case sensitive, I just left it here because the value was being retained in lowercase originally at this point
    ' CTC 093 - leave as normal case as it impacts creation of folders
    'strDeliveryFolder = LCase(strDeliveryFolder)
        
End Sub
'CTC 100 - Sending emails via SMPT
Function sendEmail(strTo As String, strSubject As String, strTextBody As String, strCC As String, Optional attachments As Variant) As Boolean

Dim objMessage As Object
Dim objConfig As Object
Dim objFields As Object
Dim i As Integer
Dim smtpAddress As String
Dim emailFrom As String

On Error Resume Next

Set objMessage = CreateObject("CDO.Message")

' Set configuration
Set objConfig = CreateObject("CDO.Configuration")
Set objFields = objConfig.Fields

' Set SMTP server details
smtpAddress = GetConfigValue("SMPTaddress")

With objFields
    .Item("http://schemas.microsoft.com/cdo/configuration/smtpserver") = smtpAddress
    .Item("http://schemas.microsoft.com/cdo/configuration/smtpserverport") = 25 ' SMTP port
    .Item("http://schemas.microsoft.com/cdo/configuration/sendusing") = 2 ' Send using SMTP
    .Update
End With

' Configure message properties
emailFrom = GetConfigValue("EmailFrom")

With objMessage
    Set .Configuration = objConfig
    .To = strTo
    .CC = strCC
    .FROM = emailFrom
    .Subject = strSubject
    .HTMLBody = strTextBody
    
    ' Attach files from the provided array (if it's an array)
    If IsArray(attachments) Then
        For i = LBound(attachments) To UBound(attachments)
            If Len(attachments(i)) > 0 Then
                .AddAttachment attachments(i)
            End If
        Next i
    End If

    .send
End With

' Error handling
If Err.Number <> 0 Then
    MsgBox "Error sending email: " & Err.Description
    sendEmail = False
Else
    sendEmail = True
End If


On Error GoTo 0

' Clean up
Set objMessage = Nothing
Set objConfig = Nothing
Set objFields = Nothing

End Function


Sub CheckNeptuneStatus()
    ' check the Neptune status for jobs which are currently running

'    On Error GoTo CheckNeptuneStatus_Error

    Dim strSQL As String
    Dim intP As Integer
    Dim strJobNumber As String
    Dim strRunNumber As String
    Dim intI As Integer
    Dim intCount As Integer
    Dim rst As Recordset
    Dim rst2 As Recordset
    Dim NeptuneVolume As Integer
    Dim RunID As Integer
    Dim NewState As String
    Dim OldState As String
            
    Set rst = New Recordset
        
    strSQL = "select * from dbo.vw_CT_JobRunStatus"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    While Not rst.EOF
        
        NewState = strAssign(rst("NewState"))
        OldState = strAssign(rst("OldState"))
        
        ' update the new job status if is has changed
        If NewState <> OldState And NewState <> "" Then
            
            ' if job has completed through Neptune and volume > 100,000 then deselect the check box for checking
            ' file volumes
            If NewState = "Neptune Complete" Then
                
                ' first get volume from Neptune to record against the job
                strSQL = "update R set R.volume = replace(V.Volume,'*','') from dbo.ct_jobrun R inner join dbo.vw_CallTraceCurrentJobsV4 V on R.CT_RunID = V.RunID where V.Volume <> '?' and R.volume is null"
                db.Execute strSQL
                                
            End If
        
            Call UpdateRunStatus(rst("RunID"), NewState, 0, "")
        End If
        
        rst.MoveNext
    Wend
    rst.Close
    
    ' check jobs where TeleAppend is null
    strSQL = "select JobNo, RunNo from dbo.vw_CallTraceCurrentJobsV4 where isnull(teleappend,'?') = '?'"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    While Not rst.EOF
        ' update the teleappend flag
        strJobNumber = strAssign(rst("JobNo"))
        strRunNumber = strAssign(rst("RunNo"))
        
        strSQL = "exec dbo.up_CT_FlagTeleAppend '" & strJobNumber & "','" & strRunNumber & "'"
        db.Execute (strSQL)
        
        rst.MoveNext
    Wend
    
End Sub

Sub PopulateRunDetailList()

Dim rst As Recordset
Dim RunID As Long
Dim ListType As String
Dim strSQL As String


RunID = lblJDRunID.Caption

' clear list
lstRunDetails.Value = Null
While lstRunDetails.ListCount > 0
    lstRunDetails.RemoveItem (0)
Wend

Set rst = New Recordset

' get the start and end times of the run selected
strSQL = "select * from dbo.vw_JobRunDetails where ct_runid = " & RunID & " order by dts"
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
                
strSQL = "LogID;Status;User;Date Time;Error;TTP"
lstRunDetails.AddItem (strSQL)
                
While Not rst.EOF
    strSQL = rst("LogID") & ";" & rst("CT_Status") & ";" & rst("UserName") & ";" & rst("DTS") & ";" & rst("ErrorType") & ";" & rst("TTP")
    lstRunDetails.AddItem (strSQL)
    rst.MoveNext
Wend
rst.Close

End Sub

' #CTC020
Sub PopulateCTFeedbackList()

cmdRefreshCTFeedback.Caption = "Refreshing..."
cmdRefreshCTFeedback.Enabled = False

Dim rst As Recordset
Dim ListType As String
Dim strSQL As String

' clear list
lstCTFeedback.Value = Null
While lstCTFeedback.ListCount > 0
    lstCTFeedback.RemoveItem (0)
Wend

Set rst = New Recordset

strSQL = "SELECT PF.[ID], PF.[Source], "
strSQL = strSQL & "CASE WHEN LEN(PF.[Object]) > 28 "
strSQL = strSQL & "THEN LEFT(PF.[Object], 25) + '...' ELSE PF.[Object] END AS [Object], "
strSQL = strSQL & "CASE WHEN LEN(PF.[Message]) > 59 "
strSQL = strSQL & "THEN LEFT(PF.[Message], 56) + '...' ELSE PF.[Message] END AS [Message], "
strSQL = strSQL & "(CONVERT(VARCHAR(5), PF.[DTS], 101) + ' ' + CONVERT(VARCHAR(8), PF.[DTS], 108)) AS DTS "
strSQL = strSQL & "FROM CallTrace.dbo.PerformanceFeedback AS PF "
strSQL = strSQL & "INNER JOIN Neptune.dbo.JIS AS JIS ON PF.JobId = JIS.JisID "
strSQL = strSQL & "WHERE JIS.JobNo = '" & Trim(lblJDJobNo.Caption) & "' AND JIS.VersionInc = '" & Trim(lblJDRunNo.Caption) & "' "
strSQL = strSQL & "ORDER BY PF.[DTS] DESC, PF.[ID] DESC "
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
                
lstCTFeedback.ColumnHeads = True
                
strSQL = "ID;Source;Object;Message;DTS"
lstCTFeedback.AddItem (strSQL)
                
While Not rst.EOF
    strSQL = rst("ID") & ";" & rst("Source") & ";" & rst("Object") & ";" & rst("Message") & ";" & rst("DTS")
    lstCTFeedback.AddItem (strSQL)
    rst.MoveNext
Wend
rst.Close

cmdRefreshCTFeedback.Caption = "Refresh CT Feedback"
cmdRefreshCTFeedback.Enabled = True

End Sub

Function Trim(varIn As Variant) As String

    If IsNull(varIn) Then
        Trim = ""
    Else
        Trim = LTrim(RTrim(varIn))
    End If

End Function

Sub MoveIfEmpty(myFile As String, TargetFolder As String)

Dim mf As Object
Dim Dummy As String

If EmptyFile(myFile) Then
    fso.MoveFile myFile, TargetFolder
End If

End Sub
Function EmptyFile(myFile As String)

Dim mf As Object
Dim Dummy As String

' nothing to do unless file exists
If Not fso.FileExists(myFile) Then
    EmptyFile = False
Else
    Set mf = fso.GetFile(myFile)
    
    If mf.Size = 0 Then
        EmptyFile = True
    ElseIf Right(myFile, 4) = ".csv" Then
        ' delimited file, need to check how many lines are in it
        Set mf = Nothing
        
        Set mf = fso.OpenTextFile(myFile, ForReading)
        Dummy = mf.ReadLine
        If mf.AtEndOfStream Then
            EmptyFile = True
        Else
            EmptyFile = False
        End If
        mf.Close
    Else
        EmptyFile = False
    End If
End If

End Function

Sub CheckFiles()

Dim OutputFolder As String
Dim ReportFolder As String
Dim NotSentFolder As String
Dim myFile As String
Dim mf As Object
Dim mfs As Object
Dim RecordCount As Long
Dim RecordLength As Long
Dim DummyLine As String
Dim MessageString As String
Dim ErrorCount As Integer
Dim strSQL As String
Dim rst As Recordset
Dim SourceFile As String

Dim ReportFile As String
Dim NeptuneSourceFile As String
Dim NeptuneDuplicateFile As String
Dim NeptuneOutputFile As String
Dim NeptuneReconFile As String
Dim NeptuneBadInputDataDNAFile As String
Dim NeptuneBadOccupierRecordsFile As String
Dim NeptuneSourceCount As Long
Dim NeptuneDuplicateCount As Long
Dim NeptuneOutputCount As Long
Dim NeptuneReconCount As Long
Dim NeptuneBadInputDataDNACount As Long
Dim NeptuneBadOccupierRecordsCount As Long

' check all files to ensure they don't contain nulls at the end
' if the check box is ticked then also count records for each file.
OutputFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Output\"
ReportFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Reports\"
NotSentFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\NotSent\"

ReportFile = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_FileCheck.txt"

If Not fso.FolderExists(NotSentFolder) Then
    fso.CreateFolder (NotSentFolder)
End If

' identify source filename from Neptune
Set rst = New Recordset

strSQL = "select * from dbo.vw_CT_NeptuneFileDetails where jobno = '" & Trim(lblJDJobNo.Caption) & "' and versioninc = " & Trim(lblJDRunNo.Caption)
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

NeptuneSourceFile = ""
NeptuneDuplicateFile = ""
NeptuneOutputFile = ""
NeptuneReconFile = ""
NeptuneBadInputDataDNAFile = ""
NeptuneBadOccupierRecordsFile = ""
NeptuneSourceCount = 0
NeptuneDuplicateCount = 0
NeptuneOutputCount = 0
NeptuneReconCount = 0
NeptuneBadInputDataDNACount = 0
NeptuneBadOccupierRecordsCount = 0

While Not rst.EOF

    Select Case LCase(rst("FileType"))
    Case "duplicate file"
        NeptuneDuplicateFile = LCase(strFileFromFolder(Trim(rst("Filename"))))
        NeptuneDuplicateCount = Val(strAssign(rst("RecordCount")))
    Case "output file"
        NeptuneOutputFile = LCase(strFileFromFolder(Trim(rst("Filename"))))
        NeptuneOutputCount = Val(strAssign(rst("RecordCount")))
    Case "recon file"
        NeptuneReconFile = LCase(strFileFromFolder(Trim(rst("Filename"))))
        NeptuneReconCount = Val(strAssign(rst("RecordCount")))
    Case "source file"
        NeptuneSourceFile = LCase(strFileFromFolder(Trim(rst("Filename"))))
        NeptuneSourceCount = Val(strAssign(rst("RecordCount")))
    Case "BadInputDataDNA"
        NeptuneBadInputDataDNAFile = LCase(strFileFromFolder(Trim(rst("Filename"))))
        NeptuneBadInputDataDNACount = Val(strAssign(rst("RecordCount")))
    Case "BadOccupierRecords"
        NeptuneBadOccupierRecordsFile = LCase(strFileFromFolder(Trim(rst("Filename"))))
        NeptuneBadOccupierRecordsCount = Val(strAssign(rst("RecordCount")))
    Case Else
        ' ignore
    End Select
    rst.MoveNext
Wend
rst.Close

If NeptuneOutputCount = 0 Then
    MsgBox ("Output file is empty - Check Report Before Proceeding")
End If

MessageString = ""
ErrorCount = 0

myFile = LCase(Dir(OutputFolder & "*.*"))
While myFile <> ""
    RecordCount = 0

    If InStr(myFile, "_readme.txt") > 0 Then
        fso.MoveFile OutputFolder & myFile, NotSentFolder
    Else
        Select Case myFile
        Case NeptuneSourceFile
            fso.MoveFile OutputFolder & NeptuneSourceFile, NotSentFolder
        Case NeptuneDuplicateFile
            Call CheckMyFile(OutputFolder, NeptuneDuplicateFile, Val(NeptuneDuplicateCount), chkAutoCheckFiles.Value, MessageString, ErrorCount)
        Case NeptuneOutputFile
            Call CheckMyFile(OutputFolder, NeptuneOutputFile, Val(NeptuneOutputCount), chkAutoCheckFiles.Value, MessageString, ErrorCount)
        Case NeptuneReconFile
            Call CheckMyFile(OutputFolder, NeptuneReconFile, Val(NeptuneReconCount), chkAutoCheckFiles.Value, MessageString, ErrorCount)
        Case NeptuneBadInputDataDNAFile
            Call CheckMyFile(OutputFolder, NeptuneBadInputDataDNAFile, Val(NeptuneBadInputDataDNACount), chkAutoCheckFiles.Value, MessageString, ErrorCount)
        Case NeptuneBadOccupierRecordsFile
            Call CheckMyFile(OutputFolder, NeptuneBadOccupierRecordsFile, Val(NeptuneBadOccupierRecordsCount), chkAutoCheckFiles.Value, MessageString, ErrorCount)
        Case Else
            ' CTC 098 - Move batchworkflowinput.csv files to NotSentFolder
            If myFile Like "*batchworkflowinput.csv" Then
                fso.MoveFile OutputFolder & myFile, NotSentFolder
            ElseIf Right(myFile, 4) = ".pdf" Then
                ' report file so nothing to do
                MessageString = MessageString & "Report File Found (" & myFile & ")" & crlf
            ElseIf Right(myFile, 4) = ".err" Then
                ' Import error file, instruct operator to generate Report
                MsgBox ("Import Error File Found (" & myFile & ") Extract Report from Neptune")
            
            ' CRD025 - KT - New InTouch template genertea emtpty files, without any audit in the SQL tables
            ' If an unidentified file is found but is empty we can ignore them, they are excluded from delivery later
            ElseIf EmptyFile(OutputFolder & myFile) Then
                MessageString = MessageString & "Unidentified Empty File Found (" & myFile & ")" & crlf
            Else
                MsgBox ("Unidentified File Found (" & myFile & ") Please Check")
            End If
            
        End Select
    End If
    
    myFile = LCase(Dir)
Wend

If ErrorCount > 0 Then
    MsgBox (Trim(ErrorCount) & " Errors Found - Please Check")
End If

Set mf = fso.CreateTextFile(ReportFolder & ReportFile)
mf.WriteLine MessageString
mf.Close

MsgBox (MessageString)

End Sub
Function ContainsNulls(myFile As String) As Boolean

Dim TF_In
Dim F As Random             ' class setup to manage files greater than 2Gb in size (which is VB's limit)
Dim FileHeader As String
Dim FileFooter As String
Dim lngBlockSize As Long
Dim result As Boolean
Dim dblFileSize  As Double

        
lngBlockSize = 10000
        
' read the first and last 1000 characters from the file
Set TF_In = fso.GetFile(myFile)
dblFileSize = TF_In.Size

' use the fileaccess class for reading header and footer
Set F = New Random

F.OpenFile (myFile)

If dblFileSize = 0 Then

    FileHeader = ""
    FileFooter = ""

ElseIf lngBlockSize < dblFileSize Then
    ' read first 10000 bytes and last 10000 bytes to see header and footer.
    Call F.SeekAbsoluteKT(0)
    FileHeader = F.ReadBytes(lngBlockSize)

    ' read last 1000 bytes to find footer
    Call F.SeekAbsoluteKT(dblFileSize - lngBlockSize - 1)
    FileFooter = F.ReadBytes(lngBlockSize)
Else
    ' read first 10000 bytes and last 10000 bytes to see header and footer.
    Call F.SeekAbsoluteKT(0)
    FileHeader = F.ReadBytes(dblFileSize)
        
    FileFooter = ""
End If
    
F.CloseFile
Set F = Nothing
    
If InStr(FileHeader, Chr(0)) > 0 Or InStr(FileFooter, Chr(0)) > 0 Then
    result = True
Else
    result = False
End If
        
ContainsNulls = result

End Function


Sub CheckMyFile(Folder As String, myFile As String, RecordCount As Long, CheckVolume As Boolean, MessageString As String, ErrorCount As Integer)
' check that the file specified doesn't contain nulls and has the correct volume of records

Dim mf As Object
Dim DummyLine As String
Dim myCount As Long


If ContainsNulls(Folder & myFile) Then
    MessageString = MessageString & myFile & " contains NULLS, Re-Output File" & crlf
    ErrorCount = ErrorCount + 1
ElseIf CheckVolume Then
    
    ' check number of records in file
    Set mf = fso.OpenTextFile(Folder & myFile, ForReading)
    
    myCount = 0
    While Not mf.AtEndOfStream
        DummyLine = mf.ReadLine
        myCount = myCount + 1
    Wend
    mf.Close
    
    ' If this is a csv file then subtract the header record
    If Right(myFile, 4) = ".csv" Then
        myCount = myCount - 1
    End If
    
    If myCount = RecordCount Then
        MessageString = MessageString & myFile & " checked, no nulls found and file count verified as " & Trim(myCount) & crlf
    Else
        MessageString = MessageString & myFile & " checked, no nulls but file count of " & Trim(myCount) & "Does not match Neptune count of " & Trim(RecordCount) & crlf
        ErrorCount = ErrorCount + 1
    End If
Else
    MessageString = MessageString & myFile & " contains no nulls, file volume not checked against Neptune" & crlf
End If

End Sub
Sub Progressjob(intRunID As Long)

Dim strSQL As String
Dim OutputFolder As String
Dim PGP_Input As String
Dim rst As Recordset
Set rst = New Recordset


    strSQL = "select * from dbo.vw_CallTrace_JobDetail where runid = " & Trim(str(intRunID))
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    If rst.EOF Then
        MsgBox ("Can't retrieve job details")
    ElseIf rst("CurrentUser") <> "" And rst("CurrentUser") <> strUserName Then
        MsgBox (rst("CurrentUser") & " has this job open")
    Else
        ' update job to say it's in use
        strSQL = "update dbo.ct_jobrun set currentuser = '" & strUserName & "' where ct_runid = " & Trim(str(intRunID))
        db.Execute strSQL
       
        pgJobDetail.Visible = True
        pgJobDetail.Enabled = True
        pgJobDetail.SetFocus
        pgJobList.Enabled = False
        ' #CTC018
        pgFileList.Enabled = False
        pgRejected.Enabled = False
        pgReports.Enabled = False
        pgeManagement.Enabled = False
        
        lblJDRunID.Caption = rst("RunID")
        lblJDJobType.Caption = rst("JobType")
        lblJDClient.Caption = rst("Client")
        lblJDJobNo.Caption = rst("JobNo")
        lblJDRunNo.Caption = rst("RunNo")
        lblJDRunCreatedBy.Caption = rst("CreatedBy")
        lblJDRunCreatedDate.Caption = rst("JobCreatedDate")
        lblJDRunDueDate.Caption = rst("DueDate")
        lblJDRunStatus.Caption = rst("Status")
        lblJDFileSource.Caption = rst("FileSource")
        lblJDFileFolder.Caption = rst("folder")
        lblJDFileName.Caption = rst("FileName")
        lblJDFileSize.Caption = rst("FileSize")
        lblJDFileCreatedDate.Caption = rst("FileCreatedDate")
        lblJDFileUpdatedDate.Caption = rst("FileUpdatedDate")
        lblJDFileSuppliedDate.Caption = rst("FileSuppliedDate")
        lblJDNotes.Caption = strAssign(rst("JobNotes"))
    
        'CTC 120

        Dim JobRunStatus As String
        Dim JobNumber As String
        Dim RunNumber As Integer
        Dim FileFolder As String
        Dim FileName As String
        Dim JobClient As String
        Dim RunID As String

        JobRunStatus = lblJDRunStatus.Caption
        JobNumber = lblJDJobNo.Caption
        RunNumber = lblJDRunNo.Caption
        FileFolder = lblJDFileFolder.Caption
        FileName = lblJDFileName.Caption
        JobClient = lblJDClient.Caption
        RunID = lblJDRunID.Caption




        If IsNull(rst("Volume")) Then
            chkAutoCheckFiles.Value = True
        ElseIf Replace(rst("Volume"), "*", "") > 2000000 Then
            chkAutoCheckFiles.Value = False
        Else
            chkAutoCheckFiles.Value = True
        End If
        
        rst.Close
        
        
        'CTC 077 need to rename from .pgp to ""
        strSQL = "select PGP_Input from CT_Jobs where Job_Number = " & "'" & Trim(lblJDJobNo.Caption) & "'"
        rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
        If Not rst.EOF Then
          If IsNull(rst("PGP_Input")) Then
              PGP_Input = "0"
          ElseIf rst("PGP_Input") = "False" Then
              PGP_Input = "0"
          ElseIf rst("PGP_Input") = "" Then
              PGP_Input = "0"
          ElseIf rst("PGP_Input") = "0" Then
              PGP_Input = "0"
          Else
              PGP_Input = rst("PGP_Input")
          End If
        End If
        rst.Close
        
        'Need to check if file was decrypted or not
        'If jobFolder is created and if it uses PGP_Input column set to Auto, that means it was decrypted
        OutputFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\"
        
        If fso.FolderExists(OutputFolder) And PGP_Input = "Auto" Then
            'The filename will no longer have .pgp extension, so need to remove that
            If InStr(LCase(lblJDFileName.Caption), ".pgp") > 0 Then lblJDFileName.Caption = Trim(Replace(lblJDFileName.Caption, ".pgp", ""))
                'Or it may have .gpg extension
            If InStr(LCase(lblJDFileName.Caption), ".gpg") > 0 Then lblJDFileName.Caption = Trim(Replace(lblJDFileName.Caption, ".gpg", ""))
        End If
        
        
        
        Call PopulateRunDetailList
        
        Call SetActions(lblJDRunStatus.Caption)
        
    End If


End Sub

Function CheckSentDetails() As String
'  provide a listing of what is in the Sent folder for the current job.  where a Zip is present include the listing of this.

Dim ReportFile As String
Dim ReportFolder As String
Dim ZipLogFile As String
Dim SentFolder As String
Dim myFile As String
Dim TextLog As String
Dim ZipFound As Boolean
Dim mf As Object

TextLog = "Sent Folder Contents:" & crlf & crlf
ReportFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Reports\"
ReportFile = ReportFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_SentFileCheck.txt"
ZipLogFile = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_ZipLog.txt"

SentFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Sent\"
ZipFound = False

If fso.FileExists(ReportFile) Then
    fso.DeleteFile ReportFile
End If

myFile = Dir(SentFolder & "*.*")
While myFile <> ""
    TextLog = TextLog & strFileFromFolder(myFile) & crlf
    
    If Right(LCase(myFile), 4) = ".zip" Then
        
        ' zip file found so create a listing of contents
        If ZipList(SentFolder & myFile, ReportFolder, ZipLogFile) Then
            ZipFound = True
        End If
    End If
    
    myFile = Dir
Wend

If ZipFound Then
    
    TextLog = TextLog & crlf & "Zip File Contents: " & crlf
    
    Set mf = fso.OpenTextFile(ReportFolder & ZipLogFile, ForReading)
    
    While Not mf.AtEndOfStream
        TextLog = TextLog & mf.ReadLine & crlf
    Wend

    mf.Close

End If

Set mf = fso.CreateTextFile(ReportFile)
mf.WriteLine (TextLog)
mf.Close

CheckSentDetails = TextLog

End Function


Sub LinkFile()
    ' First, need to check if the file details are still valid
    
    Dim strFileName As String
    Dim Source As String
    Dim strDate As String
    Dim CreatedDate As Date
    Dim UpdatedDate As Date
    Dim FileSize As Integer
    Dim blnProcess As Boolean
    Dim strSQL As String
    Dim rst As Recordset
    
    Set rst = New Recordset
    
    ' Set rstJ = New Recordset
    Dim selectedRow As Integer
    Dim JobNumber As String
    Dim IsEmpty As Boolean
    Dim FileCheck As String
    Dim CanLaunchView As String
    
    
    If Not IsNull(lstFileView.Value) Then
        ' Job number from list
        lngFileID = lstFileView.Value
        blnProcess = True
        
        ' Job number from list
        selectedRow = lstFileView.ListIndex
        selectedRow = selectedRow + 1
        JobNumber = lstFileView.Column(1, selectedRow)
        
        ' Can Launch
        CanLaunchView = lstFileView.Column(5, selectedRow)
        
        If JobNumber = "No Matches" Or JobNumber = "Multiple Matches" Then
            blnProcess = False
            MsgBox ("File has " & JobNumber & " with jobs")
        ElseIf JobNumber Like "*NA" Then
            blnProcess = False
            MsgBox ("Cannot process as " & JobNumber & " is inactive")
        End If
        
        If chkLaunchJob.Value = "True" And CanLaunchView = "False" Then
            blnProcess = False
            MsgBox "Cannot launch " & JobNumber & ". To Setup Job please deselect launching option." & vbNewLine & "Alternatively investigate an issue."
        End If
        
        ' CTC116 Additional parameter JobNumber, also function returns string instead of boolean
        FileCheck = CheckFileExists(lngFileID, JobNumber)
        
        'If a file is not present in dbo.vw_ExistingFiles
        If FileCheck = "not in view" Then
            blnProcess = False
        End If
        'If a trigger file failed to be created
        If FileCheck = "trigger notfound" Then
            blnProcess = False
        End If
        
        If blnProcess = True Then
            ' Check if the file has been processed or selected by another user
            strSQL = "select * from dbo.vw_CT_CheckFile where fileid = " & LTrim(str(lngFileID))
            rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
            
            If Not rst.EOF Then
                If Not IsNull(rst("FileUser")) Then
                    If LCase(Trim(rst("FileUser"))) = LCase(Trim(strUserName)) Then
                        ' Current user, so OK
                    Else
                        Call MsgBox("File already in use by " & Trim(rst("FileUser")), vbOKOnly)
                        blnProcess = False
                    End If
                Else
                    ' Lock the file so nobody else can use it
                    strSQL = "insert into dbo.CT_FileLock (FileID, Source, FileUser, dts) values ("
                    strSQL = strSQL & rst("FileID") & ","
                    strSQL = strSQL & "'" & rst("Source") & "',"
                    strSQL = strSQL & "'" & strUserName & "',"
                    strSQL = strSQL & "getdate())"
                    db.Execute (strSQL)
                End If
            Else
                blnProcess = False
                MsgBox ("File no longer available to process, Reject it and Refresh Data")
                lstFileView.Requery
                lstRejected.Requery
            End If
            
            ' CTC 039 - Cannot check if the file exists directly anymore as the user won't have permission to the EFT folder, added method CheckFileExists
            If blnProcess Then
                ' Need to check if the file has changed since the last update of the list.
                ' If SFTP
                If rst("Source") = "E" Then
                    If Not FileCheck = "OK" Then
                        MsgBox ("This file or version of it " & FileCheck & ", Reject it and Refresh Data")
                        Call ClearFileLock(rst("FileID"), "E")
                        blnProcess = False
                    End If
                ' If Data In
                Else
                    If Not FileCheck = "OK" Then
                        MsgBox ("This file or version of it " & FileCheck & ", Reject it and Refresh Data")
                        Call ClearFileLock(rst("FileID"), "I")
                        blnProcess = False
                    End If
                End If
            End If
            
            If blnProcess Then
                If rst("Source") = "E" Then
                    ' lblSource.Caption = "SFTP"
                    ' Source = "SFTP"
                    Source = "E"
                Else
                    ' lblSource.Caption = "Data In"
                    ' Source = "Data In"
                    Source = "I"
                End If
                
                CreatedDate = rst("CreatedDate")
                UpdatedDate = rst("UpdatedDate")
            
                If blnProcess Then
                    If CreatedDate > UpdatedDate Then
                        strDate = Format(CreatedDate, "dd mmm yyyy HH:MM")
                    Else
                        strDate = Format(UpdatedDate, "dd mmm yyyy HH:MM")
                    End If
                    
                    ' Create an entry in the Job Run Table
                    strSQL = "insert into dbo.CT_JobRun (CT_JobID,fileid,FileSource,RunNo,CreatedBy,createddate,RunStatus, DueByDate) "
                    strSQL = strSQL & "Select ct_JobID, "
                    strSQL = strSQL & Trim(str(lngFileID)) & ","
                    strSQL = strSQL & "'" & Source & "',"
                    strSQL = strSQL & "case when LastRun > LastNeptuneRun then LastRun+1 else LastNeptuneRun+1 end, "
                    strSQL = strSQL & "'" & strUserName & "',"
                    strSQL = strSQL & "getdate(),"
                    strSQL = strSQL & "'Logged',"
                    strSQL = strSQL & "dbo.fn_CallTraceDueDate_New('" & strDate & "', j.job_number ) "
                    strSQL = strSQL & "from dbo.vw_CallTraceJobList v "
                    strSQL = strSQL & "inner join dbo.ct_jobs j on v.job_number = j.job_number "
                    strSQL = strSQL & "where v.job_number = '" & JobNumber & "'"
                    
                    ' MsgBox ("Linking " & Trim(lstJobs.Value))
                    strFileName = rst("FileName")
                    MsgBox ("Linking " & strFileName & " to " & JobNumber)
                    
                    db.Execute (strSQL)
                End If
                
                rst.Close
                ' Remove the lock on the file
                Call ClearFileLock(Trim(str(lngFileID)), Source)
                         
                'SETUP JOB part
                
                Dim RunID As String
                Dim JobRunStatus As String
                Dim RunNumber As Integer
                Dim FileFolder As String
                Dim FileName As String
                Dim JobClient As String
                Dim JobType As String
                
                strSQL = "select CT_RunID from dbo.CT_JobRun where FileID = " & lngFileID
                rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
                             
                RunID = rst("CT_RunID")
                
                rst.Close
                     
                strSQL = "select * from dbo.vw_CallTrace_JobDetail where runid = " & RunID
                rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
                
           
                JobRunStatus = rst("Status")
                RunNumber = rst("RunNo")
                FileFolder = rst("folder")
                FileName = rst("FileName")
                JobClient = rst("Client")
                RunID = rst("RunID")
                JobType = rst("JobType")
                
                rst.Close

                Call SetupJob(JobRunStatus, JobNumber, RunNumber, FileFolder, FileName, JobClient, RunID)
                
                'LAUNCH JOB part
                
                If chkLaunchJob.Value Then
                    
                    Dim JobLaunchAllowed As Boolean
                    JobLaunchAllowed = JobLaunch(RunID, JobType, JobNumber, RunNumber, FileName)
                    
                    If (JobLaunchAllowed) Then
                        'launched succesfully, job details button is not visible
                        cmdLaunch.Enabled = False
                        cmdLaunch.Visible = False
                        
                    Else
                        MsgBox ("Launching job from Job Details window")
                        
                    End If
                    'job details button not visible disabled

                Else
                
                    MsgBox ("Job setup completed, while launching was not selected it needs to be done separately from Job Details page")
                    
                    cmdLaunch.Enabled = True
                    cmdLaunch.Visible = True
                    
                End If
                
                
                lstActiveJobs.Requery
                lstFileView.Requery
                pgFileList.Enabled = True
                pgJobList.Enabled = True
                pgFileList.SetFocus
                
            End If
        End If
    End If
    
End Sub


Function Get_LaunchFolder(JobNumber As String) As Integer

    Dim strSQL As String
    Dim rst As Recordset
    Dim LaunchFolder As Integer

    strSQL = "SELECT LaunchFolder FROM DataBureauDataLoadAudit.dbo.CT_Jobs where Job_Number='" & JobNumber & "'"
    
    Set rst = New Recordset
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    If rst.EOF Then
        LaunchFolder = 0
    Else
        LaunchFolder = rst("LaunchFolder")
    End If
    rst.Close

    Get_LaunchFolder = LaunchFolder

End Function

Sub ClearFolders()

On Error Resume Next

Dim SQL As String
Dim myFolder As String
Dim rst As Recordset

Set rst = New Recordset

SQL = "select folder from dbo.CT_FolderDeletions"

rst.Open SQL, db, adOpenForwardOnly, adLockReadOnly

While Not rst.EOF

    myFolder = strAssign(rst("Folder"))
        
    If fso.FolderExists(myFolder) Then
        fso.DeleteFolder myFolder
    Else
        SQL = "delete from dbo.CT_FolderDeletions where folder = '" & myFolder & "'"
        db.Execute (SQL)
    End If
    
    rst.MoveNext
Wend

On Error GoTo 0

End Sub

Function ExecutePostProcessing() As Boolean
' InTouch Tactical Solution; two jobs have non-standard requirements that need to be accounted for
'   Motormile Finance - CDA100433D
'   Lowell - CDA100443B

' Return true if no additional work required
' Return true if additional work required and completes successfully
' Return false if additional work is not successful

Dim blnReturn As Boolean
Dim strSQL As String
Dim rst As Recordset
    
Set rst = New Recordset

' Check if this job number has post-processing requirements
strSQL = "SELECT * FROM dbo.CT_Jobs WHERE Job_Number = '" & Trim(lblJDJobNo.Caption) & "' AND COALESCE(PostProcessing,'') <> ''"
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
If Not rst.EOF Then
    Call UpdateRunStatus(Trim(lblJDRunID.Caption), "Post-Processing", 0, "Test")

    Dim strOutputFolder As String
    Dim strEmptyFolder As String
    Dim strOutputFile As String
    Dim strSQLPostProc As String
    
    strOutputFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\Output\"
    strEmptyFolder = RootJobFolder & Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "\NotSent\"

    If Not fso.FolderExists(strEmptyFolder) Then
        fso.CreateFolder (strEmptyFolder)
    End If
           
    strOutputFile = Trim(lblJDJobNo.Caption) & "_" & Trim(lblJDRunNo.Caption) & "_CTOutput" & "." & strAssign(rst("OutputFileFormat"))
    strOutputFile = Replace(strOutputFile, "_0", "") ' only for first run
    strSQLPostProc = Trim(strAssign(rst("PostProcessing")))
Else
    ' No additional work required; return affirmative/no issue
    ExecutePostProcessing = True
    rst.Close
    Exit Function
End If

rst.Close
    
' Take a copy of the CTOutput file and move to NotSent so we don't overwrite it and have a backup
If Not fso.FileExists(strEmptyFolder & strOutputFile) Then
    fso.MoveFile strOutputFolder & strOutputFile, strEmptyFolder
End If

' Procs will be made to take only the CT_RunID; job number, run number and other info to be derived from SQL tables
strSQL = "EXEC " & strSQLPostProc & " @CT_RunId = " & Trim(lblJDRunID.Caption)

' KT 2019-02-13 - Bodge for Lowells to run the post processing outside the console
If Trim(lblJDJobNo.Caption) = "CDA100443C" Then
    Dim InstructionMessage As String
    Dim ClipBoard As MSForms.DataObject
    Set ClipBoard = New MSForms.DataObject
    
    ClipBoard.SetText strSQL
    ClipBoard.PutInClipboard
    
    InstructionMessage = "Job Number CDA100443C requires SQL post processing" & vbCrLf & vbCrLf
    InstructionMessage = InstructionMessage + "Open SQL Management Studio with a connection to PLLWINLVSQL002\MB21,1433" & vbCrLf & vbCrLf
    InstructionMessage = InstructionMessage + "Set the Database to DataBureauDataLoadAudit" & vbCrLf & vbCrLf
    InstructionMessage = InstructionMessage + "Execute the SQL Statement:" & vbCrLf
    InstructionMessage = InstructionMessage + strSQL & vbCrLf & vbCrLf
    InstructionMessage = InstructionMessage + "This command has been added to your clipboard" & vbCrLf & vbCrLf
    InstructionMessage = InstructionMessage + "The process could take up to an hour to complete" & vbCrLf & vbCrLf
    InstructionMessage = InstructionMessage + "Once complete press OK"
    MsgBox (InstructionMessage)
            
    If MsgBox("Did the process complete OK", vbYesNo) = vbNo Then
        Call UpdateRunStatus(lblJDRunID.Caption, "Failed", 10, "") ' Post-processing ErrorType
        ExecutePostProcessing = False
        Exit Function
    Else
        ExecutePostProcessing = True
    End If
Else
    ' Execute the proc and get result
    Set rst = New Recordset
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    If Not rst.EOF Then
        If (rst("Success")) Then
            ' proc was successful; check that new CTOutput has been created. See after rst.Close
            MsgBox strSQLPostProc & " executed successfully: " & crlf & Trim(rst("Message")), vbOKOnly + vbInformation, Trim(lblJDJobNo.Caption) & " Post-processing"
        Else
            Call UpdateRunStatus(lblJDRunID.Caption, "Failed", 10, "") ' Post-processing ErrorType
            
            MsgBox "Additional processing has failed with message: " & crlf & Trim(rst("Message")), vbCritical + vbOKOnly, Trim(lblJDJobNo.Caption) & " Post-processing"
            ExecutePostProcessing = False
        End If
    Else
        ' No results would mean fail - procs created to return values on success or failure
        MsgBox "Additional processing has not returned an expected result. See troubleshooting and CT_RunStatusLog.", vbCritical + vbOKOnly, Trim(lblJDJobNo.Caption) & " Post-processing"
        ExecutePostProcessing = False
        rst.Close
        Exit Function
    End If
        
    rst.Close
End If

' If the CTOutput file exists, happy days.
If fso.FileExists(strOutputFolder & strOutputFile) Then
    ExecutePostProcessing = True
End If

End Function

Sub CheckLaunch_AutoLaunch(strTarget As String, strSourceFile As String, strUserName As String, JobNumber As String, RunNumber As Integer, RunID As String)
' CTC 114 - New Launch Confirmation Code - Main Logic migrated to SQL

Dim rstCL As Recordset
Set rstCL = New Recordset
Dim SQL As String
Dim MonitorID As Long

' first get the LaunchID from the Neptune.dbo.MonitoredFiles table - 0 means it Timed out
SQL = "exec [dbo].[up_CT_GetLaunchID] '" & JobNumber & "', '" & strSourceFile & "'"
Set rstCL = db.Execute(SQL)
MonitorID = rstCL("MonitorID")
rstCL.Close

If MonitorID > 0 Then
    
    ' if Successful we need to add the Username to the entry and set the IsLocked Flag
    SQL = "exec [dbo].[up_CT_ConfirmLaunch] '" & JobNumber & "','" & RunNumber & "'," & CStr(MonitorID) & ",'" & strUserName & "'"
    db.Execute (SQL)
    
    MsgBox ("Launch Succeeded")
    Call UpdateRunStatus(RunID, "Running", 0, "")
    Call SetActions("Running")
    
    Call Close_DetailsPage_AutoLaunch(RunID)
Else
    fso.DeleteFile strTarget & strSourceFile
    MsgBox ("Launch Failed, Check File Watcher is Active")
End If

End Sub
Sub CheckLaunch(strTarget As String, strSourceFile As String, strUserName As String)
' CTC 114 - New Launch Confirmation Code - Main Logic migrated to SQL

Dim rstCL As Recordset
Set rstCL = New Recordset
Dim SQL As String
Dim MonitorID As Long

' first get the LaunchID from the Neptune.dbo.MonitoredFiles table - 0 means it Timed out
SQL = "exec [dbo].[up_CT_GetLaunchID] '" & Trim(lblJDJobNo.Caption) & "', '" & strSourceFile & "'"
Set rstCL = db.Execute(SQL)
MonitorID = rstCL("MonitorID")
rstCL.Close

If MonitorID > 0 Then
    
    ' if Successful we need to add the Username to the entry and set the IsLocked Flag
    SQL = "exec [dbo].[up_CT_ConfirmLaunch] '" & Trim(lblJDJobNo.Caption) & "','" & Trim(lblJDRunNo.Caption) & "'," & CStr(MonitorID) & ",'" & strUserName & "'"
    db.Execute (SQL)
    
    MsgBox ("Launch Succeeded")
    Call UpdateRunStatus(lblJDRunID.Caption, "Running", 0, "")
    Call SetActions("Running")
    
    Call Close_DetailsPage
Else
    fso.DeleteFile strTarget & strSourceFile
    MsgBox ("Launch Failed, Check File Watcher is Active")
End If

End Sub


Function JobLaunch(RunID As String, JobType As String, JobNumber As String, RunNumber As Integer, FileName As String) As Boolean


Dim strSQL As String
Dim rst As Recordset
Dim rstL As Recordset
Dim strTarget As String
Dim strSourceFolder As String
Dim strSourceFile As String
Dim strPotentialFiles() As String
Dim intI As Integer
Dim intJobsRunning As Integer
Dim intPriorRuns As Integer
Dim blnProceed As Boolean
Dim LaunchFolder As Integer
Dim MonitorID As Long

ReDim Preserve strPotentialFiles(0)

Set rst = New Recordset
Set rstL = New Recordset

blnProceed = CanLaunchJob(RunID, JobType, JobNumber, RunNumber)

If blnProceed Then
    
    strTarget = AutoLoadFolder & Trim(JobNumber) & "\"
    
    ' Determine if we need a Launch Folder
    LaunchFolder = Get_LaunchFolder(JobNumber)
    
    If LaunchFolder Then
        strSourceFolder = RootJobFolder & Trim(JobNumber) & "_" & Trim(RunNumber) & "\Launch\*.*"
            
        ' can  we identify the file to load
        intI = 0
        strPotentialFiles(intI) = Dir(strSourceFolder)
        If strPotentialFiles(intI) = "" Then
            MsgBox ("Move file to Launch into Launch folder and try again")
            Exit Function
        Else
            ' loop through all files from Launch folder
            Do
                intI = intI + 1
                If intI > UBound(strPotentialFiles) Then
                    ReDim Preserve strPotentialFiles(intI)
                End If
                strPotentialFiles(intI) = Dir
            Loop While Len(strPotentialFiles(intI))
            
            If intI > 1 Then
                MsgBox ("More than one file found in Launch folder, remove other files and try again")
                Exit Function
            Else
                strSourceFolder = RootJobFolder & Trim(JobNumber) & "_" & Trim(RunNumber) & "\Launch\"
                strSourceFile = strPotentialFiles(0)
            End If
        End If
    Else
        strSourceFolder = RootJobFolder & Trim(JobNumber) & "_" & Trim(RunNumber) & "\Original\"
        strSourceFile = FileName
    End If
        
    Set rst = New Recordset
    
    strSQL = "Select  j.JobNo as jobno, j.CustomerID, j.versioninc, j.stateid, s.StepStateID From neptune.dbo.Jis j "
    strSQL = strSQL & "inner join (select max(jisid) jisid from neptune.dbo.Jis where jobno='" & Trim(JobNumber) & "') M "
    strSQL = strSQL & "on j.jisid = M.jisid inner join neptune.dbo.JisStep s on j.jisid=s.jisid where s.stepid = 204"
    
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    If rst.EOF Then
        MsgBox ("Run Not Launched, This job number isn't setup for Auto Launch")
        rst.Close
    ElseIf rst("StateID") <> 90 And rst("VersionInc") = 0 Then
        MsgBox ("Run Not Launched, Initial run of this job is not completed and verified")
        rst.Close
    ElseIf rst("StepStateID") <> 20 Then
        MsgBox ("Run Not Launched, Data still being imported for previous run")
        rst.Close
    Else
        rst.Close
    
        ' OK we need to wait check this launch hasn't been attempted but failed previously
        strSQL = " select count(*) GotEntry from neptune.dbo.MonitoredFiles where islocked =1 and username is null and Filename = '" & strSourceFile & "' and "
        strSQL = strSQL & " Folder like '%" & Trim(JobNumber) & "%'"

        rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
        If rst("GotEntry") > 0 Then
            MsgBox ("Run Not Launched, There is already a partial launch for this run, contact Support")
            rst.Close
        Else
            rst.Close
            ' now launch the file
            If Not fso.FolderExists(strTarget) Then
                fso.CreateFolder (strTarget)
            End If
            ' CTC 102 Delete target if already exists
            If fso.FileExists(strTarget & strSourceFile) Then
                fso.DeleteFile strTarget & strSourceFile
                Call Sleep(5)
            End If
                
            fso.CopyFile strSourceFolder & strSourceFile, strTarget, False
               
            ' CTC 114 - New Launch Confirmation Code - Main Logic migrated to SQL
            Call CheckLaunch_AutoLaunch(strTarget, strSourceFile, strUserName, JobNumber, RunNumber, RunID)
            
        
        End If
    End If
End If

JobLaunch = blnProceed

End Function
' CTC 124
Function CanLaunchJob(RunID As String, JobType As String, JobNumber As String, RunNumber As Integer) As Boolean

Dim strSQL As String
Dim rst As Recordset
Dim blnProceed As Boolean
Dim intJobsRunning As Integer
Dim intPriorRuns As Integer

Set rst = New Recordset


' Check if Launch is Enabled or not
strSQL = "exec dbo.up_CT_IsLaunchEnabled"
rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly

If rst.EOF Then
    MsgBox ("Launch Currently Disabled")
    blnProceed = False
Else
    If LCase(rst("ConfigValue")) = "true" Then
        blnProceed = True
    Else
        MsgBox ("Launch Currently Disabled")
        blnProceed = False
    End If
End If
rst.Close

'If blnProceed Then
'    ' Check if the file is actually populated
'    strSQL = "Exec dbo.up_CT_FilePopulatedCheck " & RunID
'    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
'
'    If rst.EOF Then
'        MsgBox ("Unable to determine File Size")
'        blnProceed = False
'    Else
'        If rst("Populated") > 0 Then
'            blnProceed = True
'        Else
'            MsgBox ("Source File appears to be empty - Please check and Cancel if true")
'            blnProceed = False
'        End If
'    End If
'    rst.Close
'End If

' CTC 098 Additional Check for DPP Jobs
If blnProceed And LCase(JobType) = "dpp" Then
    strSQL = "Exec dbo.up_CT_DPP_LaunchCheck"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    
    If rst.EOF Then
        MsgBox ("Unable to verify Cobra Environment Status for DPP jobs")
        blnProceed = False
    Else
        If rst("Enabled") Then
            blnProceed = True
        Else
            MsgBox ("DPP Launch on " & rst("Environment") & " Currently Disabled")
            blnProceed = False
        End If
    End If
    rst.Close
End If

If blnProceed Then
    ' check if any running jobs have completed
    Call CheckNeptuneStatus
    
    ' check how many jobs are actually currently running
    strSQL = "select Count(*) as JobsRunning from dbo.CT_JobRun where RunStatus = 'Running'"
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    intJobsRunning = rst("JobsRunning")
    rst.Close
    
    If intJobsRunning < 10 Then ' #CTC032
        blnProceed = True
    ElseIf MsgBox("There are already " & Trim(str(intJobsRunning)) & " running, Do you wish to Launch This job?", vbYesNo) = vbYes Then
        blnProceed = True
    Else
        blnProceed = False
    End If
End If

If blnProceed Then
    
    ' #CTC013
    strSQL = "Exec dbo.up_CT_PreviousRunCheck '" & JobNumber & "', " & RunNumber
    rst.Open strSQL, db, adOpenForwardOnly, adLockReadOnly
    intPriorRuns = rst("PriorRuns")
    rst.Close
    
    
    If intPriorRuns = 0 Then
        blnProceed = True
    'CTC120 - updated to prevent launching multiple jobs while previous run hasn't reached one of statuses like Neptune Complete, In QC, Verified
    Else: MsgBox (Trim(str(intPriorRuns)) & " previous run(s) for this job has not finished processing, for now you cannot launch this job")
        blnProceed = False
    End If
End If

If blnProceed Then
    ' first run of a job is processed through neptune, so just update the status
    If Val(RunNumber) = 0 Then
        Call UpdateRunStatus(RunID, "Running", 0, "")
        Call SetActions("Running")
        blnProceed = False
    End If
End If

CanLaunchJob = blnProceed

End Function




function Add-XMLNode {
    param (
        [System.Xml.XmlDocument]$XML_Doc,     # Document where nodes are created
        [System.Xml.XmlElement]$XML_Parent,   # Parent element to append this node
        [string]$NodeName,                    # New node's name
        [string]$NodeValue                    # New node's value
    )
    
    # Create the new element in the document
    $Node = $XML_Doc.CreateElement($NodeName)
    $Node.InnerText = $NodeValue

    # Append the newly created element to the parent
    $XML_Parent.AppendChild($Node) | Out-Null
}

function Create-TriggerFile {
    param(
        [string]$GUIDString,
        [ref]$ActionListNames,
        [string]$SaveLocation,
        [ref]$NodeStep,
        [string]$DestinationFolder,
        [string]$JobNumber,
        [string]$JobClient
    )

    # Create an XML document with a root element
    $xmlDoc = New-Object System.Xml.XmlDocument
    $root = $xmlDoc.CreateElement("EFT_Action")
    $xmlDoc.AppendChild($root) | Out-Null

    # Add nodes to the XML document
    Add-XMLNode $xmlDoc $root "ProcessPriority" "50"
    Add-XMLNode $xmlDoc $root "GUID" $GUIDString
    Add-XMLNode $xmlDoc $root "StepSequence" ([string]$NodeStep.Value)
    Add-XMLNode $xmlDoc $root "CreationDTS" (Get-Date -Format "yyyy-MM-dd HH:mm:ss")
    Add-XMLNode $xmlDoc $root "RetriesRemaining" "2"
    Add-XMLNode $xmlDoc $root "LastAttemptDTS" ""
    Add-XMLNode $xmlDoc $root "LastResult" ""
    Add-XMLNode $xmlDoc $root "FailureNotificationEmail" ""

    # Ensure $emailNode is correctly referenced as the last child element added
    $emailNode = $root.LastChild
    Add-XMLNode $xmlDoc $emailNode "To" "DataOperationsEFT-CD@transunion.co.uk"
    Add-XMLNode $xmlDoc $emailNode "CC" "DataBureau@transunion.co.uk"
    Add-XMLNode $xmlDoc $emailNode "BCC" ""
    Add-XMLNode $xmlDoc $emailNode "Subject" "DTP - $JobClient - $JobNumber - Email Notification - Failed"
    Add-XMLNode $xmlDoc $emailNode "Message" "The DTP has failed at creating a completed file transfer trigger file in $DestinationFolder."

    Save-XML $xmlDoc $SaveLocation $GUIDString $NodeStep
}

function Create-CopyNode {
    param(
        [string]$GUIDString,
        [ref]$ActionListNames,
        [string]$SaveLocation,
        [ref]$NodeStep,
        [string]$SourceFolder,
        [string]$DestinationFolder,
        [string]$FileToCopy,
        [string]$JobNumber,
        [string]$JobClient
    )

    # Create XML document and root element
    $xmlDoc = New-Object System.Xml.XmlDocument
    $root = $xmlDoc.CreateElement("EFT_Action")
    $xmlDoc.AppendChild($root) | Out-Null

    # Adding common node elements
    Add-XMLNode $xmlDoc $root "ProcessPriority" "50"
    Add-XMLNode $xmlDoc $root "GUID" $GUIDString
    Add-XMLNode $xmlDoc $root "StepSequence" ([string]$NodeStep.Value)
    Add-XMLNode $xmlDoc $root "CreationDTS" (Get-Date -Format "yyyy-MM-dd HH:mm:ss")
    Add-XMLNode $xmlDoc $root "RetriesRemaining" "2"
    Add-XMLNode $xmlDoc $root "LastAttemptDTS" ""
    Add-XMLNode $xmlDoc $root "LastResult" ""
    Add-XMLNode $xmlDoc $root "FailureNotificationEmail" ""

    # Populate FailureNotificationEmail with email details
    $emailNode = $root.LastChild
    Add-XMLNode $xmlDoc $emailNode "To" "DataOperationsEFT-CD@transunion.co.uk"
    Add-XMLNode $xmlDoc $emailNode "CC" "DataBureau@transunion.co.uk"
    Add-XMLNode $xmlDoc $emailNode "BCC" ""
    Add-XMLNode $xmlDoc $emailNode "Subject" "DTP - $JobClient - $JobNumber - File Transfer - Failed"
    Add-XMLNode $xmlDoc $emailNode "Message" "The DTP has failed to copy $FileToCopy`r`nFrom: $SourceFolder`r`nTo: $DestinationFolder"

    # Add copy action details
    Add-XMLNode $xmlDoc $root "ActionType" "Copy"
    Add-XMLNode $xmlDoc $root "SourceFolder" $SourceFolder
    Add-XMLNode $xmlDoc $root "SourceFile" $FileToCopy
    Add-XMLNode $xmlDoc $root "DestinationFolder" $DestinationFolder
    Add-XMLNode $xmlDoc $root "DestinationFile" ""

    Save-XML $xmlDoc $SaveLocation $GUIDString $NodeStep
}

function Create-DeletionNode {
    param(
        [string]$GUIDString,
        [ref]$ActionListNames,
        [string]$SaveLocation,
        [ref]$NodeStep,
        [string]$FolderToDelete,
        [string]$JobNumber,
        [string]$JobClient
    )

   
    # Create XML document and root element
    $xmlDoc = New-Object System.Xml.XmlDocument
    $root = $xmlDoc.CreateElement("EFT_Action")
    $xmlDoc.AppendChild($root) | Out-Null

    # Common properties for the action
    Add-XMLNode $xmlDoc $root "ProcessPriority" "50"
    Add-XMLNode $xmlDoc $root "GUID" $GUIDString
    Add-XMLNode $xmlDoc $root "StepSequence" ([string]$NodeStep.Value)
    Add-XMLNode $xmlDoc $root "CreationDTS" (Get-Date -Format "yyyy-MM-dd HH:mm:ss")
    Add-XMLNode $xmlDoc $root "RetriesRemaining" "2"
    Add-XMLNode $xmlDoc $root "LastAttemptDTS" ""
    Add-XMLNode $xmlDoc $root "LastResult" ""
    Add-XMLNode $xmlDoc $root "FailureNotificationEmail" ""

    # Failure Notification Email details
    $emailNode = $root.LastChild
    Add-XMLNode $xmlDoc $emailNode "To" "DataOperationsEFT-CD@transunion.co.uk"
    Add-XMLNode $xmlDoc $emailNode "CC" "DataBureau@transunion.co.uk"
    Add-XMLNode $xmlDoc $emailNode "BCC" ""
    Add-XMLNode $xmlDoc $emailNode "Subject" "DTP failure - $JobClient - $JobNumber"
    Add-XMLNode $xmlDoc $emailNode "Message" "The DTP has failed to delete folder $FolderToDelete."

    # Deletion specific properties
    Add-XMLNode $xmlDoc $root "ActionType" "DeleteFolder"
    Add-XMLNode $xmlDoc $root "SourceFolder" $FolderToDelete
    Add-XMLNode $xmlDoc $root "SourceFile" ""
    Add-XMLNode $xmlDoc $root "DestinationFolder" ""
    Add-XMLNode $xmlDoc $root "DestinationFile" ""

    Save-XML $xmlDoc $SaveLocation $GUIDString $NodeStep
}

function Create-MoveNode {
    param(
        [string]$GUIDString,
        [ref]$ActionListNames,
        [string]$SaveLocation,
        [ref]$NodeStep,
        [string]$SourceFolder,
        [string]$DestinationFolder,
        [string]$FileToCopy,
        [string]$JobNumber,
        [string]$JobClient
    )

    # Common properties for the action
    Add-XMLNode $xmlDoc $root "ProcessPriority" "50"
    Add-XMLNode $xmlDoc $root "GUID" $GUIDString
    Add-XMLNode $xmlDoc $root "StepSequence" ([string]$NodeStep.Value)
    Add-XMLNode $xmlDoc $root "CreationDTS" (Get-Date -Format "yyyy-MM-dd HH:mm:ss")
    Add-XMLNode $xmlDoc $root "RetriesRemaining" "2"
    Add-XMLNode $xmlDoc $root "LastAttemptDTS" ""
    Add-XMLNode $xmlDoc $root "LastResult" ""
    Add-XMLNode $xmlDoc $root "FailureNotificationEmail" ""

    # Failure Notification Email details
    $emailNode = $root.LastChild
    Add-XMLNode $xmlDoc $emailNode "To" "DataOperationsEFT-CD@transunion.co.uk"
    Add-XMLNode $xmlDoc $emailNode "CC" "DataBureau@transunion.co.uk"
    Add-XMLNode $xmlDoc $emailNode "BCC" ""
    Add-XMLNode $xmlDoc $emailNode "Subject" "DTP - $JobClient - $JobNumber - File Transfer - Failed"
    Add-XMLNode $xmlDoc $emailNode "Message" "The DTP has failed to move $FileToCopy`r`nFrom: $SourceFolder`r`nTo: $DestinationFolder"

    # Move action specific properties
    Add-XMLNode $xmlDoc $root "ActionType" "Move"
    Add-XMLNode $xmlDoc $root "SourceFolder" $SourceFolder
    Add-XMLNode $xmlDoc $root "SourceFile" $FileToCopy
    Add-XMLNode $xmlDoc $root "DestinationFolder" $DestinationFolder
    Add-XMLNode $xmlDoc $root "DestinationFile" ""

    # Save the XML document
    Save-XML $xmlDoc $SaveLocation $GUIDString $NodeStep
}

function Create-DecryptionNode {
    param(
        [string]$GUIDString,
        [ref]$ActionListNames,
        [string]$SaveLocation,
        [ref]$NodeStep,
        [string]$FileName,
        [string]$SourceFolder,
        [string]$PGPFolder,
        [string]$PGP_Name,
        [string]$JobNumber,
        [string]$JobClient
    )

    # Initialize XML document
    $xmlDoc = New-Object System.Xml.XmlDocument
    $root = $xmlDoc.CreateElement("EFT_Action")
    $xmlDoc.AppendChild($root) | Out-Null

    $XML_Action = $root

    Add-XMLNode $xmlDoc $XML_Action "ProcessPriority" "50"
    Add-XMLNode $xmlDoc $XML_Action "GUID" $GUIDString
    Add-XMLNode $xmlDoc $XML_Action "StepSequence" ([string]$NodeStep.Value)
    Add-XMLNode $xmlDoc $XML_Action "CreationDTS" (Get-Date -Format "yyyy-MM-dd HH:mm:ss")
    Add-XMLNode $xmlDoc $XML_Action "RetriesRemaining" "2"
    Add-XMLNode $xmlDoc $XML_Action "LastAttemptDTS" ""
    Add-XMLNode $xmlDoc $XML_Action "LastResult" ""
    Add-XMLNode $xmlDoc $XML_Action "FailureNotificationEmail" ""

    $XML_Child = $XML_Action.LastChild

    Add-XMLNode $xmlDoc $XML_Child "To" "DataOperationsEFT-CD@transunion.co.uk"
    Add-XMLNode $xmlDoc $XML_Child "CC" "DataBureau@transunion.co.uk"
    Add-XMLNode $xmlDoc $XML_Child "BCC" ""
    Add-XMLNode $xmlDoc $XML_Child "Subject" "DTP - $JobClient - $JobNumber - Folder Creation - Failed"
    Add-XMLNode $xmlDoc $XML_Child "Message" "The DTP has failed at creating folder while decrypting $PGPFolder."

    Add-XMLNode $xmlDoc $XML_Action "ActionType" "CreateFolder"
    Add-XMLNode $xmlDoc $XML_Action "SourceFolder"
    Add-XMLNode $xmlDoc $XML_Action "SourceFile"
    Add-XMLNode $xmlDoc $XML_Action "DestinationFolder" $PGPFolder
    Add-XMLNode $xmlDoc $XML_Action "DestinationFile"

    Save-XML $xmlDoc $SaveLocation $GUIDString $NodeStep

    # Second XML action: Copy Files
    Reset-XMLDoc ([ref]$xmlDoc)  ([ref]$XML_Action)

    Add-XMLNode $xmlDoc $XML_Action "ProcessPriority" "50"
    Add-XMLNode $xmlDoc $XML_Action "GUID" $GUIDString
    Add-XMLNode $xmlDoc $XML_Action "StepSequence" ([string]$NodeStep.Value)
    Add-XMLNode $xmlDoc $XML_Action "CreationDTS" (Get-Date -Format "yyyy-MM-dd HH:mm:ss")
    Add-XMLNode $xmlDoc $XML_Action "RetriesRemaining" "2"
    Add-XMLNode $xmlDoc $XML_Action "LastAttemptDTS" ""
    Add-XMLNode $xmlDoc $XML_Action "LastResult" ""
    Add-XMLNode $xmlDoc $XML_Action "FailureNotificationEmail" ""
    $XML_Child = $XML_Action.LastChild

    Add-XMLNode $xmlDoc $XML_Child "To" "DataOperationsEFT-CD@transunion.co.uk"
    Add-XMLNode $xmlDoc $XML_Child "CC" "DataBureau@transunion.co.uk"
    Add-XMLNode $xmlDoc $XML_Child "BCC" ""
    Add-XMLNode $xmlDoc $XML_Child "Subject" "DTP - $JobClient - $JobNumber - File Transfer - Failed"
    Add-XMLNode $xmlDoc $XML_Child "Message" "The DTP has failed before decryption to copy $FileName From: $SourceFolder To: $PGPFolder"

    Add-XMLNode $xmlDoc $XML_Action "ActionType" "Copy"
    Add-XMLNode $xmlDoc $XML_Action "SourceFolder" $SourceFolder
    Add-XMLNode $xmlDoc $XML_Action "SourceFile" $FileName
    Add-XMLNode $xmlDoc $XML_Action "DestinationFolder" $PGPFolder
    # Subsequent actions should be similar but with appropriate modifications for the specific actions.
    Save-XML $xmlDoc $SaveLocation $GUIDString $NodeStep

    # Third XML action: Decrypt Files
    Reset-XMLDoc ([ref]$xmlDoc)  ([ref]$XML_Action)

    Add-XMLNode $xmlDoc $XML_Action "ProcessPriority" "50"
    Add-XMLNode $xmlDoc $XML_Action "GUID" $GUIDString
    Add-XMLNode $xmlDoc $XML_Action "StepSequence" ([string]$NodeStep.Value)
    Add-XMLNode $xmlDoc $XML_Action "CreationDTS" (Get-Date -Format "yyyy-MM-dd HH:mm:ss")
    Add-XMLNode $xmlDoc $XML_Action "RetriesRemaining" "2"
    Add-XMLNode $xmlDoc $XML_Action "LastAttemptDTS" ""
    Add-XMLNode $xmlDoc $XML_Action "LastResult" ""
    Add-XMLNode $xmlDoc $XML_Action "FailureNotificationEmail" ""
    $XML_Child = $XML_Action.LastChild

    Add-XMLNode $xmlDoc $XML_Child "To" "DataOperationsEFT-CD@transunion.co.uk"
    Add-XMLNode $xmlDoc $XML_Child "CC" "DataBureau@transunion.co.uk"
    Add-XMLNode $xmlDoc $XML_Child "BCC" ""
    Add-XMLNode $xmlDoc $XML_Child "Subject" "DTP - $JobClient - $JobNumber - File Decryption - Failed"
    Add-XMLNode $xmlDoc $XML_Child "Message" "The DTP has failed at decrypting $FileName in $PGPFolder"

    Add-XMLNode $xmlDoc $XML_Action "ActionType" "Decrypt"
    Add-XMLNode $xmlDoc $XML_Action "SourceFolder" $pgpF
    Add-XMLNode $xmlDoc $XML_Action "SourceFile" $FileName
    Add-XMLNode $xmlDoc $XML_Action "DestinationFolder" ""
    Add-XMLNode $xmlDoc $XML_Action "DestinationFile" ""
    Add-XMLNode $xmlDoc $XML_Action "EncryptionKey" $PGP_Name
    Save-XML $xmlDoc $SaveLocation $GUIDString $NodeStep
}


function Reset-XMLDoc([ref]$xmlDoc, [ref]$XML_Action) {
    $xmlDoc.Value.RemoveAll()
    $XML_Action.Value = $xmlDoc.Value.CreateElement("EFT_Action")
    $xmlDoc.Value.AppendChild($XML_Action.Value) | Out-Null
}

function Save-XML([System.Xml.XmlDocument]$xmlDoc, [string]$SaveLocation, [string]$GUIDString, [ref]$NodeStep) {
    $ActionXMLPath = Join-Path $SaveLocation ("50_" + $GUIDString + "_" + ('{0:D2}' -f $NodeStep.Value) + ".xml")
    $xmlDoc.Save($ActionXMLPath)
    $ActionListNames.Value += $ActionXMLPath + ";"
    $NodeStep.Value++
}











$Global:dbconnectionString = "Data Source=pllwinlvsql002\mb21,1433;Integrated Security=SSPI;Initial Catalog=DataBureauDataLoadAudit"
$connection = New-Object System.Data.SqlClient.SqlConnection($connectionString)
$currentUserName = $env:USERNAME
# Load all the functions we may need 
. "\\cig.local\data\AppData\SFTP\Data\Usr\DataBureau\Configuration\Scripts\Test\CallTrace Console\CTC124_125\Functions.ps1"

$strPotentialFiles = @()
$blnProceed = Can-LaunchJob -RunID $RunID -JobType $JobType -JobNumber $JobNumber -RunNumber $RunNumber

if ($blnProceed) {
    $strTarget = "$AutoLoadFolder$($JobNumber.Trim())\"
    $LaunchFolder = Get-LaunchFolder -JobNumber $JobNumber

    if ($LaunchFolder) {
        $strSourceFolder = "$RootJobFolder$($JobNumber.Trim())_$($RunNumber.Trim())\Launch\*.*"
        $intI = 0
        $strPotentialFiles += Get-ChildItem -Path $strSourceFolder -Name

        if ($strPotentialFiles.Count -eq 0) {
            WriteLog "Move file to Launch into Launch folder and try again"
            return $false
        } elseif ($strPotentialFiles.Count -gt 1) {
            WriteLog "More than one file found in Launch folder, remove other files and try again"
            return $false
        } else {
            $strSourceFolder = "$RootJobFolder$($JobNumber.Trim())_$($RunNumber.Trim())\Launch\"
            $strSourceFile = $strPotentialFiles[0]
        }
    } else {
        $strSourceFolder = "$RootJobFolder$($JobNumber.Trim())_$($RunNumber.Trim())\Original\"
        $strSourceFile = $FileName
    }


    $strSQL = @"
SELECT j.JobNo as jobno, j.CustomerID, j.versioninc, j.stateid, s.StepStateID 
FROM neptune.dbo.Jis j 
INNER JOIN (SELECT MAX(jisid) jisid FROM neptune.dbo.Jis WHERE jobno='$($JobNumber.Trim())') M 
ON j.jisid = M.jisid 
INNER JOIN neptune.dbo.JisStep s ON j.jisid = s.jisid 
WHERE s.stepid = 204
"@
    $connection = New-Object System.Data.SqlClient.SqlConnection
    $connection.ConnectionString = $dbConnectionString
    $connection.Open()
    $command = $connection.CreateCommand()
    $command.CommandText = $strSQL
    $reader = $command.ExecuteReader()

    if ($reader.HasRows) {
        $reader.Read()
        $stateID = $reader["StateID"]
        $stepStateID = $reader["StepStateID"]
        $strFile = $reader["Folder"] + $reader["Filename"]
        $reader.Close()

    if ($result.Rows.Count -eq 0) {
        WriteLog "Run Not Launched, This job number isn't setup for Auto Launch"
        return $false
    } elseif ($result.Rows[0].StateID -ne 90 -and $result.Rows[0].VersionInc -eq 0) {
        WriteLog "Run Not Launched, Initial run of this job is not completed and verified"
        return $false
    } elseif ($result.Rows[0].StepStateID -ne 20) {
        WriteLog "Run Not Launched, Data still being imported for previous run"
        return $false
    } else {
        $strSQL = "SELECT COUNT(*) AS GotEntry FROM dbo.MonitoredFiles WHERE islocked = 1 AND username IS NULL AND Filename = '$strSourceFile' AND Folder LIKE '%$($JobNumber.Trim())%'"
        $result = Query-SQL -sql $strSQL -connectionString $connectionString

        if ($result.Rows[0].GotEntry -gt 0) {
            WriteLog "Run Not Launched, There is already a partial launch for this run, contact Support"
            return $false
        } else {
            if (-Not (Test-Path $strTarget)) {
                New-Item -ItemType Directory -Path $strTarget -Force
            }

            if (Test-Path "$strTarget$strSourceFile") {
                Remove-Item -Path "$strTarget$strSourceFile" -Force
                Start-Sleep -Seconds 5
            }

            Copy-Item -Path "$strSourceFolder$strSourceFile" -Destination $strTarget -Force
            Check-LaunchAutoLaunch -strTarget $strTarget -strSourceFile $strSourceFile -strUserName $strUserName -JobNumber $JobNumber -RunNumber $RunNumber -RunID $RunID
        }
    }
}

# CanLaunchJob function
function Can-LaunchJob {
    param (
        [string]$RunID,
        [string]$JobType,
        [string]$JobNumber,
        [int]$RunNumber
    )

    $connectionString = "Server=your_server;Database=DataBureauDataLoadAudit;Integrated Security=True;"
    $strSQL = "EXEC dbo.up_CT_IsLaunchEnabled"
    $result = Query-SQL -sql $strSQL -connectionString $connectionString

    if ($result.Rows.Count -eq 0 -or $result.Rows[0].ConfigValue.ToLower() -ne "true") {
        WriteLog "Launch Currently Disabled"
        return $false
    }

    if ($JobType.ToLower() -eq "dpp") {
        $strSQL = "EXEC dbo.up_CT_DPP_LaunchCheck"
        $result = Query-SQL -sql $strSQL -connectionString $connectionString

        if ($result.Rows.Count -eq 0 -or $result.Rows[0].Enabled -ne $true) {
            WriteLog "DPP Launch on $($result.Rows[0].Environment) Currently Disabled"
            return $false
        }
    }

    Check-NeptuneStatus

    $strSQL = "SELECT COUNT(*) AS JobsRunning FROM dbo.CT_JobRun WHERE RunStatus = 'Running'"
    $result = Query-SQL -sql $strSQL -connectionString $connectionString
    $intJobsRunning = $result.Rows[0].JobsRunning

    if ($intJobsRunning -ge 10) {
        $msgResult = Read-Host "There are already $intJobsRunning jobs running, Do you wish to Launch This job? (Y/N)"
        if ($msgResult -ne "Y") {
            return $false
        }
    }

    $strSQL = "EXEC dbo.up_CT_PreviousRunCheck '$JobNumber', $RunNumber"
    $result = Query-SQL -sql $strSQL -connectionString $connectionString
    $intPriorRuns = $result.Rows[0].PriorRuns

    if ($intPriorRuns -gt 0) {
        WriteLog "$intPriorRuns previous run(s) for this job has not finished processing, for now you cannot launch this job"
        return $false
    }

    if ($RunNumber -eq 0) {
        Update-RunStatus -strRunID $RunID -strStatus "Running" -intError 0 -strTTP ""
        Set-Actions -JobRunStatus "Running"
        return $false
    }

    return $true
}

# CheckNeptuneStatus function
function Check-NeptuneStatus {
    $connectionString = "Server=your_server;Database=DataBureauDataLoadAudit;Integrated Security=True;"
    $strSQL = "SELECT * FROM dbo.vw_CT_JobRunStatus"
    $result = Query-SQL -sql $strSQL -connectionString $connectionString

    foreach ($row in $result.Rows) {
        $NewState = $row.NewState
        $OldState = $row.OldState

        if ($NewState -ne $OldState -and $NewState -ne "") {
            if ($NewState -eq "Neptune Complete") {
                $strSQL = "UPDATE R SET R.volume = REPLACE(V.Volume,'*','') FROM dbo.ct_jobrun R INNER JOIN dbo.vw_CallTraceCurrentJobsV4 V ON R.CT_RunID = V.RunID WHERE V.Volume <> '?' AND R.volume IS NULL"
                Execute-SQLCommand -sql $strSQL -connectionString $connectionString
            }

            Update-RunStatus -strRunID $row.RunID -strStatus $NewState -intError 0 -strTTP ""
        }
    }

    $strSQL = "SELECT JobNo, RunNo FROM dbo.vw_CallTraceCurrentJobsV4 WHERE ISNULL(teleappend,'?') = '?'"
    $result = Query-SQL -sql $strSQL -connectionString $connectionString

    foreach ($row in $result.Rows) {
        $strJobNumber = $row.JobNo
        $strRunNumber = $row.RunNo
        $strSQL = "EXEC dbo.up_CT_FlagTeleAppend '$strJobNumber','$strRunNumber'"
        Execute-SQLCommand -sql $strSQL -connectionString $connectionString
    }
}

# CheckLaunch_AutoLaunch function
function Check-LaunchAutoLaunch {
    param (
        [string]$strTarget,
        [string]$strSourceFile,
        [string]$strUserName,
        [string]$JobNumber,
        [int]$RunNumber,
        [string]$RunID
    )

    $connectionString = "Server=your_server;Database=neptune;Integrated Security=True;"
    $strSQL = "EXEC dbo.up_CT_GetLaunchID '$JobNumber', '$strSourceFile'"
    $result = Query-SQL -sql $strSQL -connectionString $connectionString
    $MonitorID = $result.Rows[0].MonitorID

    if ($MonitorID -gt 0) {
        $strSQL = "EXEC dbo.up_CT_ConfirmLaunch '$JobNumber','$RunNumber',$MonitorID,'$strUserName'"
        Execute-SQLCommand -sql $strSQL -connectionString $connectionString
        WriteLog "Launch Succeeded"
        Update-RunStatus -strRunID $RunID -strStatus "Running" -intError 0 -strTTP ""
        Set-Actions -JobRunStatus "Running"
        Close-DetailsPageAutoLaunch -RunID $RunID
    } else {
        Remove-Item -Path "$strTarget$strSourceFile" -Force
        WriteLog "Launch Failed, Check File Watcher is Active"
    }
}

$dbconnectionString = "Data Source=pllwinlvsql002\mb21,1433;Integrated Security=SSPI;Initial Catalog=DataBureauDataLoadAudit"
$currentUserName = $env:USERNAME

# Load all the functions we may need 
."\\cig.local\data\AppData\SFTP\Data\Usr\DataBureau\Configuration\Scripts\Test\CallTrace Console\CTC124_125\Functions.ps1"
."\\cig.local\data\AppData\SFTP\Data\Usr\DataBureau\Configuration\Scripts\Test\CallTrace Console\CTC124_125\CreateXML.ps1"
# Function to execute a SQL command

#Get-FileViewData takes values from vw_CallTraceFilesToDisplay and stores it into global variables for further processing. 

If (Get-FileViewData)
{
    # Emulate business logic conditions
    $blnProcess = $true
    if ($JobNumber -eq "No Matches" -or $JobNumber -eq "Multiple Matches") {
        $blnProcess = $false
        WriteLog "File has $JobNumber with jobs"
    } elseif ($JobNumber -like "*NA") {
        $blnProcess = $false
        WriteLog "Cannot process as $JobNumber is inactive"
    }

    # Check file existence using a placeholder function
    $fileCheck = CheckFileExists "FileID" "JobNumber" 

    If ($fileCheck -eq "not in view" -or $fileCheck -eq "trigger notfound")
        {
         $blnProcess = $false
        }

    # SQL checks and locking logic
    if ($blnProcess) {
        $sql = "SELECT fileuser FROM dbo.vw_CT_CheckFile WHERE fileid = '$FileID'" 
        $fileUser = Get-SQLScalar -Query $sql
            if ($null -ne $fileUser) {
                if ($fileUser.ToLower().Trim() -eq $currentUserName.ToLower().Trim()) {
                    # Current user, so OK
                } else {
                    WriteLog "File already in use by $fileUser"
                    $blnProcess = $false
                }
            } else {
                # Lock the file logic
                $sql = "INSERT INTO dbo.CT_FileLock (FileID, Source, FileUser, dts) VALUES ($FileID, $Source, $currentUserName, GETDATE())"
                Execute-SQLCommand $sql
            }
        } else {
            WriteLog "File no longer available to process, reject it and refresh data"
            $blnProcess = $false
        }
    }

    if ($blnProcess) {
        if ($Source -eq "E") {
            if ($fileCheck -ne "OK") {
                WriteLog "This file or version of it $fileCheck, Reject it and Refresh Data"
                ClearFileLock $FileID "E"
                $blnProcess = $false
            }
        } else {
            if ($fileCheck -ne "OK") {
                WriteLog "This file or version of it $fileCheck, Reject it and Refresh Data"
                ClearFileLock $FileID "I"
                $blnProcess = $false
            }
        }
    }

     #Continue processing if the file is still okay to process
    if ($blnProcess) {
        $source = $table.Rows[0]["Source"]
        $createdDate = Get-SQLScalar -Query "SELECT createddate FROM dbo.vw_CT_CheckFile WHERE fileid = '$FileID'" 
        $updatedDate = Get-SQLScalar -Query "SELECT updateddate FROM dbo.vw_CT_CheckFile WHERE fileid = '$FileID'" 
        
        # Determine the most recent date between created and updated dates
        if ($createdDate -gt $updatedDate) {
            $strDate = $createdDate.ToString("dd MMM yyyy HH:mm")
        } else {
            $strDate = $updatedDate.ToString("dd MMM yyyy HH:mm")
        }

    # Check and update job run details
    if ($blnProcess) {
        $sql = "INSERT INTO dbo.CT_JobRun (CT_JobID, fileid, FileSource, RunNo, CreatedBy, createddate, RunStatus, DueByDate) "
        $sql += "SELECT ct_JobID, $FileID, $Source, case when LastRun > LastNeptuneRun then LastRun+1 else LastNeptuneRun+1 end, "
        $sql += "$currentUserName, GETDATE(), 'Logged', dbo.fn_CallTraceDueDate_New($strDate, j.job_number) "
        $sql += "FROM dbo.vw_CallTraceJobList v INNER JOIN dbo.ct_jobs j ON v.job_number = j.job_number "
        $sql += "WHERE v.job_number = '$JobNumber'"
        Execute-SQLCommand $sql

        WriteLog "Linking file to job number $JobNumber"

        # Clear any locks if necessary
        ClearFileLock "FileID" "Source"  # Placeholder function call
    }

    # Additional job setup logic
    $strSQL = "SELECT RunNo FROM dbo.vw_CallTraceCurrentJobsV4 WHERE Job_Number = '$JobNumber'"
    $runNumber = Query-SQL -sql $strSQL -connectionString $connectionString

    $strSQL = "select * from dbo.vw_CallTrace_JobDetail where runid = $RunID"
    $status = Query-SQL -sql $strSQL -connectionString $connectionString  

    function Setup-Job($status, $JobNumber, $runNumber, $SourceFolder, $FileName, $JobClient, $RunID) {
        # Add your implementation
        WriteLog "Setting up job for run ID: $RunID"
    }

}



Functions 

$Global:dbconnectionString = "Data Source=pllwinlvsql002\mb21,1433;Integrated Security=SSPI;Initial Catalog=DataBureauDataLoadAudit"

function Get-SQLScalar {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)] [String] $Query
    )

    $Connection = New-Object System.Data.SQLClient.SQLConnection($dbconnectionString)
    $Connection.Open()
    $Command = New-Object System.Data.SQLClient.SQLCommand($Query, $Connection)
    $SQLScalar = $Command.ExecuteScalar()
    $Connection.Close()

    return $SQLScalar
}

function ExecuteSQLCommand ($sql) {
    $onnection = New-Object System.Data.SQLClient.SQLConnection($dbconnectionString)
    $command = $connection.CreateCommand()
    $command.CommandText = $sql
    $connection.Open()
    $command.ExecuteNonQuery()
    $connection.Close()
}

function WriteLog {
    param(
        [Parameter(Mandatory = $true)][string]$AuditMessage,
        [switch]$ErrorFound
    )
    f
    $MyDate = get-date

    [string]$FullMessage = $MyDate.ToLongDateString() + "|" + $MyDate.ToLongTimeString() + "|" + $AuditMessage

    $LogFilePath = "\\cig.local\data\AppData\SFTP\Data\Usr\DataBureau\Configuration\Scripts\Test\CallTrace Console\CTC124_125\CTFileProcessing.log"

    AppendLog -LogFilePath $LogFilePath -LogMessage $FullMessage

    if($ErrorFound) {
        Write-Error $AuditMessage
    }
    else {
        Write-Host $AuditMessage
    }
}

function AppendLog {
    param (
        [Parameter(Mandatory = $True)]$LogFilePath,
        [Parameter(Mandatory = $True)]$LogMessage
    )
    try {
        $Writer = New-Object System.IO.StreamWriter($LogFilePath, $true)
        $Writer.WriteLine($LogMessage)
    }
    finally {
        $Writer.Dispose()
    }
}


Function ClearFileLock($fileID, $fileSource) {
    $sql = "EXECUTE [dbo].[up_CT_ClearFileLock] $fileID, '$fileSource'"
    Execute-SQLCommand $sql
}

function Get-FileViewData {

    $connection = New-Object System.Data.SqlClient.SqlConnection
    $connection.ConnectionString = $dbConnectionString
    $connection.Open()

    $command = $connection.CreateCommand()
    $command.CommandText = "SELECT TOP 1 * FROM [DataBureauDataLoadAudit].[dbo].[vw_CallTraceFilesToDisplay_New_2] where Job_Number like '%CDA%'"
    $reader = $command.ExecuteReader()

    if ($reader.HasRows) {
        $reader.Read()

        $global:FileID = $reader["fileid"]
        $global:Source = $reader["Source"]
        $global:SourceFolder = $reader["Folder"]
        $global:FileName = $reader["filename"]
        $global:JobNumber = $reader["Job_Number"]
        $global:ReceivedDate = $reader["ReceiveddDate"]
        $global:FileSize = $reader["filesize"]
        $global:CanLaunch = $reader["CanLaunch"]

        $reader.Close()
    } else {
        $reader.Close()
        WriteLog "No records found in the view."
    }

    $connection.Close()

}


function Check-FileExists { 

param( 
[int]$lngFileID)

$strFile = $SourceFolder + $FileName

$connection = New-Object System.Data.SqlClient.SqlConnection
$connection.ConnectionString = $dbConnectionString
$connection.Open()

$command = $connection.CreateCommand()
$command.CommandText = "select * from dbo.vw_ExistingFiles where fileid = $lngFileID"
$reader = $command.ExecuteReader()

if ($reader.HasRows) {
    $reader.Read()
    $strFile = $reader["Folder"] + $reader["Filename"]
    $reader.Close()

    $HeaderInFirstRow = Get-HeaderInFirstRow -JobNumber $JobNumber

    if ($strFile -like "\\cig.local\Data\Marketing Solutions Departments\Production\*") {
        $result = Check-FileExistsLocal -myFile $strFile -HeaderInFirstRow $HeaderInFirstRow
    } else {
        $result = Check-FileExistsEFT -lngFileID $lngFileID -JobNumber $JobNumber -HeaderInFirstRow $HeaderInFirstRow -strFile $strFile
    }

    return $result
} else {
    $reader.Close()
    WriteLog "file no longer in view (someone else may have processed it)"
    "not in view"
}

$connection.Close()
}



function CheckFileExists_Local {
    param (
        [string]$myFile,
        [bool]$headerInFirstRow
    )

    if (-Not (Test-Path $myFile)) {
        return "not found"
    } else {
        $fileInfo = Get-Item $myFile
        if ($fileInfo.Length -gt 0) {
            if ($headerInFirstRow) {
                if (ContainsMultipleLines $myFile) {
                    return "OK"
                } else {
                    return "Is empty"
                }
            } else {
                return "OK"
            }
        } else {
            return "Is empty"
        }
    }
}

function Get-HeaderInFirstRow {
    param (
        [string]$jobNumber
    )

    $sql = "SELECT HeadersInFirstRow FROM neptunefileimporter.[fileimporter].[Jobs] WHERE JobId IN (SELECT Max(JobId) FROM neptunefileimporter.[fileimporter].[Jobs] WHERE DestinationTable = '$jobNumber')"
    $result = Get-SQLScalar -Query $sql 

    if ($result -ne $null) {
        return $result
    } else {
        WriteLog "Error retrieving HeadersInFirstRow value from fileimporter.Jobs"
        return $false
    }
}


function ContainsMultipleLines {
    param (
        [string]$fileName
    )

    $lineCount = 0
    try {
        $reader = [System.IO.File]::OpenText($fileName)
        while (-not $reader.EndOfStream -and $lineCount -lt 2) {
            $reader.ReadLine()
            $lineCount++
        }
        $reader.Close()
    } catch {
        WriteLog "Error reading file $fileName"
    }
    return $lineCount -gt 1
}

function Remove-FileWithRetry {
    param (
        [string]$filePath,
        [int]$maxAttempts = 6,
        [int]$retryIntervalSeconds = 10
    )

    if (-Not (Test-Path $filePath)) {
        WriteLog "File does not exist: $filePath"
        return
    }

    $attemptCount = 0
    $success = $false

    do {
        try {
            # Attempt to delete the file
            Remove-Item $filePath -ErrorAction Stop
            $success = $true
            break
        } catch {
            # Log the error and wait before retrying
            WriteLog "Failed to delete file: $filePath. Error: $_"
            Start-Sleep -Seconds $retryIntervalSeconds
        }

        $attemptCount++
    } while ($attemptCount -lt $maxAttempts)

    # Check if deletion was not successful after all attempts
    if (-not $success) {
        WriteLog "Trigger file '$filePath' could not be deleted after multiple attempts."
    }
}


function CheckFileExists_EFT {

    param (
        [int]$lngFileID,
        [string]$jobNumber,
        [bool]$headerInFirstRow,
        [string]$strFile
    )

     # Define base folders
    $fileExistsTriggerFolder = "PathToYourTriggerFolder"  # Update this path as necessary
    $toProcessFolder = Join-Path $fileExistsTriggerFolder "ToProcess"
    $foundFolder = Join-Path $fileExistsTriggerFolder "Found"
    $notFoundFolder = Join-Path $fileExistsTriggerFolder "NotFound"
    
    # Define specific file paths
    $triggerFilePath = Join-Path $toProcessFolder "$lngFileID.trg"
    $foundNotEmptyPath = Join-Path $foundFolder "NotEmpty\$lngFileID.trg"
    $foundEmptyPath = Join-Path $foundFolder "Empty\$lngFileID.trg"
    $fileNotFoundPath = Join-Path $notFoundFolder "$lngFileID.trg"
    
    # Delete existing trigger files
    Remove-FileWithRetry $fileFoundNotEmptyPath
    Remove-FileWithRetry $fileFoundEmptyPath
    Remove-FileWithRetry $fileNotFoundPath
    Remove-FileWithRetry $fileExistsTriggerFullPath

    # Create a new trigger file
    [System.IO.File]::WriteAllLines($fileExistsTriggerFullPath, @($strFile, $jobNumber, $headerInFirstRow))
    
    # Check for trigger file appearance in folders
    $attemptCount = 0
    $maxAttempts = 3
    
    do {
        Start-Sleep -Seconds 3
        if ((Test-Path $fileFoundNotEmptyPath) -or (Test-Path $fileFoundEmptyPath) -or (Test-Path $fileNotFoundPath)) {
            break
        }
        $attemptCount++
    } while ($attemptCount -lt $maxAttempts)

    if ($attemptCount -eq $maxAttempts) {
        WriteLog "Trigger file not found after multiple attempts."
        return "trigger notfound"
    }

    if (Test-Path $fileNotFoundPath) {
        Remove-FileWithRetry $fileNotFoundPath
        return "not found"
    } elseif (Test-Path $fileFoundNotEmptyPath) {
        Remove-FileWithRetry $fileFoundNotEmptyPath
        return "OK"
    } elseif (Test-Path $fileFoundEmptyPath) {
        Remove-FileWithRetry $fileFoundEmptyPath
        return "Is empty"
    }
}


function Setup-Job {
    param (
        [string]$JobRunStatus,
        [string]$JobNumber,
        [int]$RunNumber,
        [string]$FileFolder,
        [string]$FileName,
        [string]$JobClient,
        [string]$RunID
    )

    # Error handling
    trap {
        if ($FileCopied) {
            WriteLog "Error occurred after copying the file to job folder. Contact Technical Operator."
        } else {
            WriteLog "Error occurred before copying the file. Make sure the file exists and try again."
        }
        WriteLog "Error: $($_.Exception.Message)"
        continue
    }

    $strJobFolder = "$RootJobFolder$JobNumber`_$RunNumber"
    $FileCopied = $false

    if ($JobRunStatus.ToLower() -eq "logged") {
        $LaunchFolder = Get-LaunchFolder -JobNumber $JobNumber

        $sql = "SELECT ISNULL(DeleteSource, 0) as DeleteSource FROM dbo.CT_Jobs WHERE Job_Number='$JobNumber'"
        $DeleteSource = Get-SQLScalar -Query $sql

        if ((IsSourceFileLocal -FileFolder $FileFolder)) {
            New-Item -ItemType Directory -Path $strJobFolder -Force
            New-Item -ItemType Directory -Path "$strJobFolder\Original" -Force
            if ($LaunchFolder) {
                New-Item -ItemType Directory -Path "$strJobFolder\Launch" -Force
            }
            New-Item -ItemType Directory -Path "$strJobFolder\Output" -Force
            New-Item -ItemType Directory -Path "$strJobFolder\Reports" -Force
            New-Item -ItemType Directory -Path "$strJobFolder\Sent" -Force
            New-Item -ItemType Directory -Path "$strJobFolder\Old" -Force
            Move-Item -Path "$FileFolder\$FileName" -Destination "$strJobFolder\Original\"
        } else {
            $sql = "SELECT ConfigValue FROM dbo.CT_Config WHERE ConfigItem='DTPPendingFolder'"
            $SaveLocation = Get-SQLScalar -Query $sql

            $sql = "SELECT ConfigValue FROM dbo.CT_Config WHERE ConfigItem='DTPToLoadFolder'"
            $DTPToLoad = Get-SQLScalar -Query $sql

            $InterimSubFolder = "$InterimFolder$JobNumber`_$RunNumber"
            if (Test-Path $InterimSubFolder) {
                Remove-Item -Path $InterimSubFolder -Recurse -Force
            }
            New-Item -ItemType Directory -Path $InterimSubFolder -Force

            $GUIDString = [guid]::NewGuid().ToString()
            $nodeStep = 1
            $DecryptionAdded = $false

            $sql = "SELECT PGP_Input FROM dbo.CT_Jobs WHERE Job_Number='$JobNumber'"
            $PGP_Input = Get-SQLScalar -Query $sql

            if ([string]::IsNullOrEmpty($PGP_Input) -or $PGP_Input -eq "0" -or $PGP_Input -eq "False") {
                $PGP_Input = "0"
            } else {
                $DecryptionAdded = $true
            }

            if ($DecryptionAdded) {
                $PGPTempFolder = "$PGPTemporaryFolder$GUIDString"
                $PGP_Input = ""
                Create-DecryptionNode -GUIDString $GUIDString -ActionListNames ([ref]$ActionListNames) -SaveLocation $SaveLocation -nodeStep ([ref]$nodeStep) -FileName $FileName -FileFolder $FileFolder -PGPTempFolder $PGPTempFolder -PGP_Input $PGP_Input -JobNumber $JobNumber -JobClient $JobClient

                if ($FileName.ToLower().Contains(".pgp")) {
                    $FileName = $FileName.Replace(".pgp", "")
                } elseif ($FileName.ToLower().Contains(".gpg")) {
                    $FileName = $FileName.Replace(".gpg", "")
                }

                Create-CopyNode -GUIDString $GUIDString -ActionListNames ([ref]$ActionListNames) -SaveLocation $SaveLocation -nodeStep ([ref]$nodeStep) -SourceFolder $PGPTempFolder -DestinationFolder $InterimSubFolder -FileName $FileName -JobNumber $JobNumber -JobClient $JobClient

                Create-DeletionNode -GUIDString $GUIDString -ActionListNames ([ref]$ActionListNames) -SaveLocation $SaveLocation -nodeStep ([ref]$nodeStep) -FolderPath $PGPTempFolder -JobNumber $JobNumber -JobClient $JobClient
            } else {
                if ($DeleteSource -eq 1 -or $FileFolder.ToLower().Contains("\production\data in\calltrace\") -or $FileFolder.ToLower().Contains("\neptune\calltrace\intouch\")) {
                    Create-MoveNode -GUIDString $GUIDString -ActionListNames ([ref]$ActionListNames) -SaveLocation $SaveLocation -nodeStep ([ref]$nodeStep) -SourceFolder $FileFolder -DestinationFolder $InterimSubFolder -FileName $FileName -JobNumber $JobNumber -JobClient $JobClient
                } else {
                    Create-CopyNode -GUIDString $GUIDString -ActionListNames ([ref]$ActionListNames) -SaveLocation $SaveLocation -nodeStep ([ref]$nodeStep) -SourceFolder $FileFolder -DestinationFolder $InterimSubFolder -FileName $FileName -JobNumber $JobNumber -JobClient $JobClient
                }
            }

            Create-TriggerNode -GUIDString $GUIDString -ActionListNames ([ref]$ActionListNames) -SaveLocation $SaveLocation -nodeStep ([ref]$nodeStep) -InterimSubFolder $InterimSubFolder -JobNumber $JobNumber -RunNumber $RunNumber

            $FirstActionPath = ($ActionListNames -split ";")[0]
            Move-Item -Path $FirstActionPath -Destination $DTPToLoad

            $StartTime = [System.Diagnostics.Stopwatch]::StartNew()
            $MaxProcessingTime = 120

            while (-not (Test-Path "$InterimSubFolder\$JobNumber`_$RunNumber.trg")) {
                $SecondsElapsed = $StartTime.Elapsed.TotalSeconds

                if (Test-Path "$DTPFailedFolder*$GUIDString*") {
                    WriteLog "Request to copy the file failed. Please contact Technical Operator."
                    return
                }

                if ($SecondsElapsed -gt $MaxProcessingTime) {
                    WriteLog "Request to copy the file from client to Job folder exceeded its time limit - $($MaxProcessingTime / 60) minutes" 
                        $MaxProcessingTime += 60              
                }
            }

            $StartTime.Stop()

            New-Item -ItemType Directory -Path $strJobFolder -Force
            New-Item -ItemType Directory -Path "$strJobFolder\Original" -Force
            if ($LaunchFolder) {
                New-Item -ItemType Directory -Path "$strJobFolder\Launch" -Force
            }
            New-Item -ItemType Directory -Path "$strJobFolder\Output" -Force
            New-Item -ItemType Directory -Path "$strJobFolder\Reports" -Force
            New-Item -ItemType Directory -Path "$strJobFolder\Sent" -Force
            New-Item -ItemType Directory -Path "$strJobFolder\Old" -Force

            Move-Item -Path "$InterimSubFolder\$FileName" -Destination "$strJobFolder\Original\"

            Remove-Item -Path $InterimSubFolder -Recurse -Force
        }

        $FileCopied = $true

        if ($FileName.TrimEnd() -ne $FileName.Trim()) {
            Move-Item -Path "$strJobFolder\Original\$($FileName.TrimEnd())" -Destination "$strJobFolder\Original\$($FileName.Trim())"
            $FileName = $FileName.Trim()
        }

        $JobRunStatus = "Pre-Processing"
        Update-RunStatus -strRunID $RunID -strStatus $JobRunStatus -intError 0 -strTTP ""

        WriteLog "Folders Created and Source File Copied"
    }

}

# Function to get LaunchFolder
function Get-LaunchFolder {
    param (
        [string]$JobNumber
    )

    $query = "SELECT LaunchFolder FROM dbo.CT_Jobs WHERE Job_Number='$JobNumber'"
    $result = Get-SQLScalar -Query $query

    if ($null -eq $result) {
        return 0
    } else {
        return [int]$result
    }
}

# Function to trim whitespace from a string
function Trim {
    param (
        [string]$varIn
    )

    if ($null -eq $varIn) {
        return ""
    } else {
        return $varIn.Trim()
    }
}

# Function to update run status
function Update-RunStatus {
    param (
        [string]$strRunID,
        [string]$strStatus,
        [int]$intError,
        [string]$strTTP
    )

    $connectionString = "Server=your_server;Database=DataBureauDataLoadAudit;Integrated Security=True;"
    $connection = New-Object System.Data.SqlClient.SqlConnection
    $connection.ConnectionString = $connectionString
    $connection.Open()

    # Update the run status for the given job
    $updateQuery = "UPDATE dbo.CT_JobRun SET RunStatus = '$strStatus' WHERE CT_RunID = $strRunID"
    $command = $connection.CreateCommand()
    $command.CommandText = $updateQuery
    $command.ExecuteNonQuery()

    # Add an entry to the run status audit log
    if ($strStatus.ToLower() -eq "failed") {
        $insertQuery = @"
INSERT INTO dbo.CT_RunStatusLog (CT_RunID, CT_Status, UserName, UpdateDate, ErrorType, TTP)
SELECT $strRunID, '$strStatus', '$strUserName', GETDATE(), ErrorType, '$strTTP'
FROM dbo.CT_ErrorType
WHERE CT_ErrorID = $(Trim $intError)
"@
    } else {
        $insertQuery = "INSERT INTO dbo.CT_RunStatusLog (CT_RunID, CT_Status, UserName, UpdateDate) VALUES ($strRunID, '$strStatus', '$strUserName', GETDATE())"
    }
    $command.CommandText = $insertQuery
    $command.ExecuteNonQuery()

    # If completed, update the job run with completion date
    if ($strStatus.ToLower() -eq "complete") {
        $completionQuery = "UPDATE dbo.CT_JobRun SET CompletedDate = GETDATE() WHERE CT_RunID = $strRunID"
        $command.CommandText = $completionQuery
        $command.ExecuteNonQuery()
    }
}

